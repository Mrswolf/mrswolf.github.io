<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>swolf的博客</title>
  
  <subtitle>记录我的学习生活</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://mrswolf.github.io/"/>
  <updated>2019-12-15T07:38:56.869Z</updated>
  <id>https://mrswolf.github.io/</id>
  
  <author>
    <name>swolf</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>主成分分析（Principle Component Analysis)</title>
    <link href="https://mrswolf.github.io/zh-cn/2019/12/11/PCA/"/>
    <id>https://mrswolf.github.io/zh-cn/2019/12/11/PCA/</id>
    <published>2019-12-11T07:41:21.000Z</published>
    <updated>2019-12-15T07:38:56.869Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><p>PCA是非常常用的一种矩阵分解算法，PCA通过旋转原始空间来使得数据在各个正交轴上的投影最大，通过选择前几个正交轴可以实现数据降维的目的。<a id="more"></a></p><h2 id="基本算法"><a href="#基本算法" class="headerlink" title="基本算法"></a>基本算法</h2><p>PCA的优化问题如下：</p><script type="math/tex; mode=display">\newcommand{\argmin}{\mathop{\mathrm{argmin}}}\begin{equation*}\begin{aligned}& \argmin_W& & -\mathrm{trace}(W^TXX^TW) \\& \text{s.t}& & W^TW=I \\& & & X \in \mathbb{R}^{M \times N} \\& & & M \in \mathbb{R}^{M \times M}\end{aligned}\end{equation*}</script><p>其中$X$是数据，$W$是投影矩阵，$N$是样本点个数，$M$是特征个数。PCA要求数据$X$做零均值处理，其解为特征值分解问题：</p><script type="math/tex; mode=display">\begin{equation*}\begin{aligned}(XX^T)w_k = \lambda w_k\end{aligned}\end{equation*}</script><p>其中$w_k$是$W$的第k个列向量。PCA后的新数据特征为</p><script type="math/tex; mode=display">\begin{equation*}\begin{aligned}\hat{X}  = W^T X\end{aligned}\end{equation*}</script><h2 id="sklearn实现分析"><a href="#sklearn实现分析" class="headerlink" title="sklearn实现分析"></a>sklearn实现分析</h2><h3 id="svd替代eig"><a href="#svd替代eig" class="headerlink" title="svd替代eig"></a>svd替代eig</h3><p>sklearn中的PCA实现并未使用eig而是使用svd，主要原因是svd比eig具有更好的数值稳定性（当然代价是其计算时间要比eig更长）。使用svd代替eig也是很多学者如Andrew Ng建议的策略，在StackExchange上也有关于svd和eig的相关讨论<a href="https://stats.stackexchange.com/questions/314046/why-does-andrew-ng-prefer-to-use-svd-and-not-eig-of-covariance-matrix-to-do-pca" target="_blank" rel="noopener">讨论1</a>、<a href="https://stats.stackexchange.com/questions/79043/why-pca-of-data-by-means-of-svd-of-the-data" target="_blank" rel="noopener">讨论2</a>。sklearn中直接对数据矩阵$X$而不是协方差矩阵$XX^T$做svd，其等价关系如下：</p><script type="math/tex; mode=display">\begin{equation*}\begin{aligned}X &= U \Sigma V^T  \\XX^T &= U \Sigma^2 U^T \\W &= U \\\hat{X} &= W^TX = \Sigma V^T\end{aligned}\end{equation*}</script><h3 id="sign-ambiguity问题"><a href="#sign-ambiguity问题" class="headerlink" title="sign ambiguity问题"></a>sign ambiguity问题</h3><p>sklearn的PCA代码中还考虑了svd的sign ambiguity问题，即每个奇异向量的符号在求解过程中是不确定的（例如，将$u_k$和$v_k$同时乘以-1也满足求解条件）。svd算法(包括eig)中的奇异向量符号只是确保数值稳定性的副产品，类似随机分配符号，并无实际意义。</p><p>sklearn使用<code>svd_flip(u, v, u_based_descision=True)</code>函数来确保输出确定性的奇异向量符号，例如，如果<code>u_based_decision=True</code>，则要求$U$的每一列奇异向量中绝对值最大的元素的符号始终为正，$V$也要相对的做出调整。</p><p>鉴于MATLAB是算法开发的标准之一，我很好奇MATLAB是如何处理SVD的sign ambiguity问题的。MATLAB的svd函数的<a href="https://www.mathworks.com/help/matlab/ref/double.svd.html;jsessionid=a0f6c96366744a55e10e9731d76b#bu2_0hq-U" target="_blank" rel="noopener">官方文档</a>中有这样一句话:</p><blockquote><p>Different machines and releases of MATLAB® can produce different singular vectors that are still numerically accurate. Corresponding columns in U and V can flip their signs, since this does not affect the value of the expression A = U<em>S</em>V’.</p></blockquote><p>MATLAB的eig函数的<a href="https://www.mathworks.com/help/matlab/ref/eig.html#btgapg5-1-V" target="_blank" rel="noopener">官方文档</a>中亦提到：</p><blockquote><p>For real eigenvectors, the sign of the eigenvectors can change.</p></blockquote><p>可以看出MATLAB也未保证符号的确定性。同样在MATALB的社区里也有人问了这个<a href="https://www.mathworks.com/matlabcentral/answers/325234-request-for-guidance-about-the-sign-of-singular-value-decomposition" target="_blank" rel="noopener">问题</a>，并引导我看了这篇<a href="https://www.sandia.gov/~tgkolda/pubs/pubfiles/SAND2007-6422.pdf" target="_blank" rel="noopener">Resolving the Sign Ambiguity in the Singular Value Decompostion</a>的文献。</p><p>文献中指出，sklearn的<code>svd_flip</code>方法是一种临时方案（ad hoc），并未从数据分析或者解释的角度来解决sign ambiguity问题。解决sign ambiguity的核心是如何为奇异向量选择一个“有意义”的符号。什么叫“有意义”？比方说我们要研究4种品牌汽车的每公里耗油量，做了4次抽样，构成数据矩阵</p><script type="math/tex; mode=display">\begin{equation*}\begin{aligned}X = \begin{bmatrix}4&22&3&5 \\1&5&1&1 \\11&69&10&14 \\11&69&10&14\end{bmatrix}\end{aligned}\end{equation*}</script><p>其中每一列是一种品牌汽车的耗油量，每一行为抽样情况，svd分解有$X=U \Sigma V^T$。我们来看一下<code>numpy.linalg.svd</code>计算得到的$V$的第一个奇异向量：</p><script type="math/tex; mode=display">\begin{equation*}\begin{aligned}v_1 = \begin{bmatrix}-0.15 \\-0.96 \\-0.14 \\-0.20 \end{bmatrix}\end{aligned}\end{equation*}</script><p>$v_1$实际指明了耗油量空间的一个向量，然而我们知道耗油量没有负值（如果有的话人类就拥有无限能源了），一个完全指向负的方向没有任何意义，如果改变$v_1$的符号，变为：</p><script type="math/tex; mode=display">\begin{equation*}\begin{aligned}v_1 = \begin{bmatrix}0.15 \\0.96 \\0.14 \\0.20 \end{bmatrix}\end{aligned}\end{equation*}</script><p>结果就合理多了。</p><p>文献中指出，<strong>奇异向量的符号应当与大多数数据样本向量的符号相同，从几何上来看，奇异向量应当指向大多数向量指向的方向</strong>。下图是我从文献中截取的，深色蓝线是正确的奇异向量方向，浅色蓝线是数据向量。</p><img src="/zh-cn/2019/12/11/PCA/figure1.png" title="正确符号示意"><p>翻译成数学语言（我按照自己的理解和习惯转化成优化问题，与文献的原始表述并不一致，有兴趣的读者可以看原始文献)，纠正符号算法的核心是对于每一个奇异向量$u_k$，寻找符号$s_k$优化以下目标函数</p><script type="math/tex; mode=display">\newcommand{\argmax}{\mathop{\mathrm{argmax}}}\begin{equation*}\begin{aligned}& \argmax_{s_k \in \{ 1, -1 \}}& & s_k (\sum_{j=1}^M u_k^Tx_{\ast j} + \sum_{i=1}^N x_{i \ast}v_k)\end{aligned}\end{equation*}</script><p>根据两项求和项的符号即可决定$s_k$的符号，该算法解决左右奇异向量冲突的情况（例如左奇异向量符号是-1,右奇异向量符号为1）的方法是选择求和绝对值最大的奇异向量的符号作为共有符号。文献中指出，该算法仅在上述求和项不为0的情况下有效（在0附近奇异向量的符号为任意情况），具体算法实现如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sign_flip</span><span class="params">(u, s, vh=None)</span>:</span></span><br><span class="line">    <span class="string">"""Flip signs of SVD or EIG.</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> vh <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        total_proj = np.sum(u*s, axis=<span class="number">0</span>)</span><br><span class="line">        signs = np.sign(total_proj)</span><br><span class="line">        </span><br><span class="line">        random_idx = (signs==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> np.any(random_idx):</span><br><span class="line">            signs[random_idx] = <span class="number">1</span></span><br><span class="line">            warnings.warn(<span class="string">"The magnitude is close to zero, the sign will become arbitrary."</span>)</span><br><span class="line">            </span><br><span class="line">        u = u*signs</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> u, s</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        left_proj = np.sum(s[:, np.newaxis]*vh, axis=<span class="number">-1</span>)</span><br><span class="line">        right_proj = np.sum(u*s, axis=<span class="number">0</span>)</span><br><span class="line">        total_proj = left_proj + right_proj</span><br><span class="line">        signs = np.sign(total_proj)</span><br><span class="line">        </span><br><span class="line">        random_idx = (signs==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> np.any(random_idx):</span><br><span class="line">            signs[random_idx] = <span class="number">1</span></span><br><span class="line">            warnings.warn(<span class="string">"The magnitude is close to zero, the sign will become arbitrary."</span>)</span><br><span class="line"></span><br><span class="line">        u = u*signs</span><br><span class="line">        vh = signs[:, np.newaxis]*vh</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> u, s, vh</span><br></pre></td></tr></table></figure><p><strong>未完待续</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
&lt;p&gt;PCA是非常常用的一种矩阵分解算法，PCA通过旋转原始空间来使得数据在各个正交轴上的投影最大，通过选择前几个正交轴可以实现数据降维的目的。
    
    </summary>
    
      <category term="每天学点sklearn" scheme="https://mrswolf.github.io/categories/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E7%82%B9sklearn/"/>
    
    
      <category term="matrix decomposition" scheme="https://mrswolf.github.io/tags/matrix-decomposition/"/>
    
  </entry>
  
  <entry>
    <title>manjaro踩坑记</title>
    <link href="https://mrswolf.github.io/zh-cn/2019/05/24/manjaro%E8%B8%A9%E5%9D%91%E8%AE%B0/"/>
    <id>https://mrswolf.github.io/zh-cn/2019/05/24/manjaro踩坑记/</id>
    <published>2019-05-24T06:20:00.000Z</published>
    <updated>2019-12-15T07:38:04.297Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><p>最近换了linux系统，选择了manjaro发行版，在这里记录一下踩坑历程。<a id="more"></a></p><p>总体来说，manjaro还是不错的。<br>优点：</p><ul><li>显卡驱动安装省心,好评</li><li>aur里有各种软件</li><li>pacman安装方便</li><li>背靠arch文档丰富</li><li>相对arch稳定多</li></ul><p>缺点：</p><ul><li>需要对linux有一定的了解</li><li>办公软件无解，老老实实用office</li><li>滚动更新还是有几率挂的，做好系统备份（还在研究中）</li></ul><h3 id="系统安装"><a href="#系统安装" class="headerlink" title="系统安装"></a>系统安装</h3><p>我选择了manjaro的KDE版，用rufus以DD模式制作U盘启动器，在BIOS里设置以U盘启动后进入manjaro的live环境，根据自带的指南安装manjaro并重启,最好按照全英文设置来，中文可以以后在系统里改, 驱动选择nonfree。<br><strong>manjaro下载</strong><a href="https://manjaro.org/download/kde/" target="_blank" rel="noopener">https://manjaro.org/download/kde/</a><br><strong>rufus下载</strong><a href="https://rufus.ie/" target="_blank" rel="noopener">https://rufus.ie/</a></p><h3 id="更改pacman镜像"><a href="#更改pacman镜像" class="headerlink" title="更改pacman镜像"></a>更改pacman镜像</h3><p>manjaro基于arch，用pacman做软件包管理，但是由于众所周知的原因，国内连接国外镜像非常慢，因此需要更改为国内镜像。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 利用pacman-mirrors选择镜像，或者手动在/etc/pacman.d/mirrorlist里添加</span><br><span class="line">sudo pacman -S pacman-mirrors</span><br><span class="line"></span><br><span class="line"># 中国区镜像排序，一般选择前两个镜像</span><br><span class="line">sudo pacman-mirrors -i -c China -m rank</span><br></pre></td></tr></table></figure></p><h3 id="同步更新"><a href="#同步更新" class="headerlink" title="同步更新"></a>同步更新</h3><p>新系统先更新一下。。。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo pacman -Syy</span><br><span class="line">sudo pacman -Syu</span><br></pre></td></tr></table></figure></p><h3 id="移除Octopi换Pamac"><a href="#移除Octopi换Pamac" class="headerlink" title="移除Octopi换Pamac"></a>移除Octopi换Pamac</h3><p>KDE自带的软件管理器octopi比较丑，可以换另一个管理器pamac。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo pacman -S pamac</span><br><span class="line">sudo pacman -R octopi</span><br></pre></td></tr></table></figure></p><p>打开pamac，搜索octopi，移除所有octopi相关的orphan依赖包。</p><h3 id="安装yay"><a href="#安装yay" class="headerlink" title="安装yay"></a>安装yay</h3><p>尽管pamac也可以安装AUR里的软件包（需要在pamac设置里开启aur选项），但yay更符合命令行的习惯。安装yay非常简单，在pamac里搜索安装即可，安装完成后选择清华aur镜像。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yay --aururl &quot;https://aur.tuna.tsinghua.edu.cn&quot; --save</span><br></pre></td></tr></table></figure></p><h3 id="调整Baloo限制"><a href="#调整Baloo限制" class="headerlink" title="调整Baloo限制"></a>调整Baloo限制</h3><p>Baloo是manjaroKDE的文件搜索软件，我的电脑上查看日志发现Baloo经常有watch limit error，调整以下选项<br><a href="https://wiki.archlinux.org/index.php/Baloo" target="_blank" rel="noopener">https://wiki.archlinux.org/index.php/Baloo</a><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 编辑/etc/sysctl.d/50-max_user_watches.conf</span><br><span class="line">fs.inotify.max_user_watches = 524288</span><br></pre></td></tr></table></figure></p><h3 id="安装base-devel"><a href="#安装base-devel" class="headerlink" title="安装base-devel"></a>安装base-devel</h3><p>安装基础开发工具<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo pacman -S base-devel</span><br></pre></td></tr></table></figure></p><h3 id="中文输入法"><a href="#中文输入法" class="headerlink" title="中文输入法"></a>中文输入法</h3><p>安装中文谷歌拼音输入法和字体<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo pacman -S adobe-source-han-sans-cn-fonts adobe-source-han-serif-cn-fonts</span><br><span class="line">sudo pacman -S fcitx fcitx-googlepinyin fcitx-im fcitx-configtool</span><br><span class="line"></span><br><span class="line"># 编辑 ~/.xinitrc</span><br><span class="line">export GTK_IM_MODULE=fcitx</span><br><span class="line">export QT_IM_MODULE=fcitx</span><br><span class="line">export XMODIFIERS=@im=fcitx</span><br><span class="line"></span><br><span class="line"># 重新登录后，在开始菜单System里找到Input Method设置，添加谷歌拼音输入法</span><br></pre></td></tr></table></figure></p><h3 id="科学上网"><a href="#科学上网" class="headerlink" title="科学上网"></a>科学上网</h3><p>大部分国内软件安装的问题都是因为众所周知的原因，并且优秀资料多为英文，因此科学上网在中国是非常有必要的。arch社区对此有非常详细的指导（中文资料领先英文，中国部分领域领先的典范^_^）。<br><a href="https://wiki.archlinux.org/index.php/Shadowsocks" target="_blank" rel="noopener">https://wiki.archlinux.org/index.php/Shadowsocks</a><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ss的libev版本比较稳定</span><br><span class="line">sudo pacman -S shadowsocks-libev</span><br><span class="line">sudo mkdir /etc/shadowsocks</span><br><span class="line"></span><br><span class="line"># 配置ss文件(服务器地址和密码)</span><br><span class="line">sudo nano /etc/shadowsocks/config.json</span><br><span class="line"></span><br><span class="line"># 以daemon开机启动</span><br><span class="line">sudo systemctl start shadowsocks-libev@config</span><br><span class="line">sudo systemctl enable shadowsocks-libev@config</span><br><span class="line"></span><br><span class="line"># 下载gfwpac列表，将其填入firefox的代理配置URL（file:///home/xxx/gfwlist.pac）</span><br><span class="line">wget https://raw.githubusercontent.com/petronny/gfwlist2pac/master/gfwlist.pac</span><br><span class="line"></span><br><span class="line"># 配置http代理转发socks5代理</span><br><span class="line">sudo pacman -S privoxy</span><br><span class="line"></span><br><span class="line"># 编辑 /etc/privoxy/config，添加socks5转发和http监听地址</span><br><span class="line">forward-socks5 / 127.0.0.1:1080 .</span><br><span class="line">listen-address  127.0.0.1:8010</span><br><span class="line"></span><br><span class="line"># 重启privoxy服务</span><br><span class="line">sudo systemctl enable privoxy.service</span><br><span class="line">sudo systemctl restart privoxy.service</span><br><span class="line"></span><br><span class="line"># 安装proxychains-ng</span><br><span class="line">sudo pacman -S proxychains-ng</span><br><span class="line"></span><br><span class="line"># 编辑 /etc/proxychains.conf, 修改最后一行为</span><br><span class="line">socks5 127.0.0.1 1080</span><br></pre></td></tr></table></figure></p><h3 id="SSD配置"><a href="#SSD配置" class="headerlink" title="SSD配置"></a>SSD配置</h3><p>如果安装在SSD上，可以选择以下命令<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo systemctl enable fstrim.timer</span><br><span class="line">sudo systemctl start fstrim.timer</span><br></pre></td></tr></table></figure></p><h3 id="Ryzen随机卡死问题"><a href="#Ryzen随机卡死问题" class="headerlink" title="Ryzen随机卡死问题"></a>Ryzen随机卡死问题</h3><p>我的manjaro KDE有时候会随机卡死，啥也不管用，因此启动以下magic key命令<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 编辑或新建99-sysctl.conf</span><br><span class="line">sudo nano /etc/sysctl.d/99-sysctl.conf</span><br><span class="line"># 添加以下内容, 按Alt+PrtSc+REISUB可以安全重启</span><br><span class="line">kernel.sysrq = 1</span><br></pre></td></tr></table></figure></p><p>看日志没发现哪里出问题，目前主要感觉是内存频率过高导致的（BIOS已经是最新），我是3200的内存条，调到2133最稳定，卡死几率较小。</p><p>updated:<br>好像没用，现在卡死的频率几乎是一天一次。</p><p>updated:<br>我查到这个问题可能是AMD Ryzen处理器的一个bug,需要disable C6 state， 链接如下<br><a href="https://github.com/jfredrickson/disable-c6" target="_blank" rel="noopener">https://github.com/jfredrickson/disable-c6</a><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yay -S disable-c6-systemd</span><br><span class="line">sudo modprobe msr </span><br><span class="line"></span><br><span class="line"># 编辑/etc/modules-load.d/modules.conf, 添加msr</span><br><span class="line"># List of modules to load at boot</span><br><span class="line">msr</span><br><span class="line"></span><br><span class="line">sudo systemctl enable disable-c6.service</span><br><span class="line">sudo systemctl start disable-c6.service</span><br></pre></td></tr></table></figure></p><p><del>目前测试中</del>。已稳定运行一周!</p><h3 id="安装nfs-utils"><a href="#安装nfs-utils" class="headerlink" title="安装nfs-utils"></a>安装nfs-utils</h3><p>实验室数据存在NFS服务器上，因此安装nfs-utils<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo pacman -S nfs-utils</span><br><span class="line"></span><br><span class="line"># 挂载NFS服务</span><br><span class="line">sudo mount server:/nfs/data /mountpoint/on/client</span><br><span class="line"></span><br><span class="line"># 修改 /etc/fstab, 添加</span><br><span class="line">server:/nfs/data /mountpoint/on/client nfs defaults 0 0</span><br></pre></td></tr></table></figure></p><h3 id="安装Java"><a href="#安装Java" class="headerlink" title="安装Java"></a>安装Java</h3><p>我安装的是arch官方维护的openjdk。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo pacman -S jdk-openjdk</span><br><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure></p><h3 id="安装vscode"><a href="#安装vscode" class="headerlink" title="安装vscode"></a>安装vscode</h3><p>vscode是我常用的编辑器<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo pacman -S code</span><br></pre></td></tr></table></figure></p><h3 id="安装miniconda"><a href="#安装miniconda" class="headerlink" title="安装miniconda"></a>安装miniconda</h3><p>我使用miniconda管理环境并安装python相关package。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh</span><br><span class="line">sh Miniconda3-latest-Linux-x86_64.sh </span><br><span class="line"></span><br><span class="line"># 编辑 ~/.bash_profile,在最后添加如下环境变量（注意PATH要在前面）</span><br><span class="line">export PATH=&quot;$PATH:$HOME/miniconda3/bin&quot;</span><br><span class="line"></span><br><span class="line"># 编辑完成后</span><br><span class="line">source .bash_profile</span><br></pre></td></tr></table></figure></p><h3 id="更改miniconda的pypi镜像"><a href="#更改miniconda的pypi镜像" class="headerlink" title="更改miniconda的pypi镜像"></a>更改miniconda的pypi镜像</h3><p>众所周知的原因。。。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 进入base环境或新建的python环境</span><br><span class="line">source activate</span><br><span class="line"></span><br><span class="line">pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure></p><h3 id="安装pytorch和tensorflow"><a href="#安装pytorch和tensorflow" class="headerlink" title="安装pytorch和tensorflow"></a>安装pytorch和tensorflow</h3><p>manjaro的cuda（10.1）和cudnn（7.5）版本都是最新的，pytorch和tensorflow没有对应的二进制版本，pip不好用。最简单的方式是使用conda安装。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 安装cuda和cudnn</span><br><span class="line">sudo pacman -S cuda cudnn</span><br><span class="line"></span><br><span class="line"># 进入conda环境，py36是我的python3.6.5环境</span><br><span class="line">source activate py36</span><br><span class="line"></span><br><span class="line">conda install tensorflow-gpu</span><br><span class="line">conda install pytorch torchvision cudatoolkit=10.0 -c pytorch</span><br></pre></td></tr></table></figure></p><h3 id="安装nodejs"><a href="#安装nodejs" class="headerlink" title="安装nodejs"></a>安装nodejs</h3><p>为了写博客，我得安装hexo。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 安装nvm版本管理（直接安装nodejs会有权限错误）</span><br><span class="line">yay -S nvm</span><br><span class="line">source /usr/share/nvm/init-nvm.sh</span><br><span class="line">nvm install node</span><br><span class="line"></span><br><span class="line"># 安装npm和hexo</span><br><span class="line">sudo pacman -S npm</span><br><span class="line">npm install hexo-cli -g</span><br><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></p><h3 id="安装网易云音乐"><a href="#安装网易云音乐" class="headerlink" title="安装网易云音乐"></a>安装网易云音乐</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yay -S netease-cloud-music</span><br></pre></td></tr></table></figure><h3 id="安装teamviewer"><a href="#安装teamviewer" class="headerlink" title="安装teamviewer"></a>安装teamviewer</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yay -S teamviewer</span><br><span class="line">sudo systemctl start teamviewerd</span><br><span class="line">sudo systemctl enable teamviewerd</span><br></pre></td></tr></table></figure><h3 id="安装虚拟机"><a href="#安装虚拟机" class="headerlink" title="安装虚拟机"></a>安装虚拟机</h3><p>用虚拟机装win10使用office和其他专用软件，或者用office online来处理文档。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo pacman -S virt-manager qemu vde2 ebtables dnsmasq bridge-utils openbsd-netcat</span><br><span class="line"></span><br><span class="line"># 编辑/etc/libvirt/qemu.conf，提供UEFI安装</span><br><span class="line">nvram = [</span><br><span class="line">    &quot;/usr/share/ovmf/x64/OVMF_CODE.fd:/usr/share/ovmf/x64/OVMF_VARS.fd&quot;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"># pci passthrough， 编辑/etc/default/grub, 在以下行内添加amd_iommu=on或intel_iommu=on</span><br><span class="line">GRUB_CMDLINE_LINUX_DEFAULT=&quot;quiet amd_iommu=on&quot;</span><br><span class="line"></span><br><span class="line">sudo systemctl enable libvirtd.service dnsmasq.service ebtables.service virtlogd.service</span><br><span class="line">sudo systemctl start libvirtd.service dnsmasq.service ebtables.service virtlogd.service</span><br></pre></td></tr></table></figure></p><p>安装Win10虚拟机需要在下载虚拟机驱动，系统安装完毕后挂载光驱安装相应驱动<br><a href="https://docs.fedoraproject.org/en-US/quick-docs/creating-windows-virtual-machines-using-virtio-drivers/index.html" target="_blank" rel="noopener">https://docs.fedoraproject.org/en-US/quick-docs/creating-windows-virtual-machines-using-virtio-drivers/index.html</a><br>此外，cpu核心数需要根据cpu pinning一节手动调整，virt-manager图形界面无法调整（默认单核心）<br><a href="https://wiki.archlinux.org/index.php/PCI_passthrough_via_OVMF#CPU_pinning" target="_blank" rel="noopener">https://wiki.archlinux.org/index.php/PCI_passthrough_via_OVMF#CPU_pinning</a><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">su</span><br><span class="line"># 切换默认编辑器为nano</span><br><span class="line">EDITOR=nano</span><br><span class="line"></span><br><span class="line"># 列出当前所有虚拟机名称</span><br><span class="line">virsh list --all</span><br><span class="line"></span><br><span class="line">virsh edit vmname</span><br><span class="line"># 修改以下内容（4核8线程)</span><br><span class="line">...</span><br><span class="line">&lt;vcpu placement=&apos;static&apos;&gt;8&lt;/vcpu&gt;</span><br><span class="line">&lt;iothreads&gt;1&lt;/iothreads&gt;</span><br><span class="line">&lt;cputune&gt;</span><br><span class="line">  &lt;vcpupin vcpu=&apos;0&apos; cpuset=&apos;2&apos;/&gt;</span><br><span class="line">  &lt;vcpupin vcpu=&apos;1&apos; cpuset=&apos;3&apos;/&gt;</span><br><span class="line">  &lt;vcpupin vcpu=&apos;2&apos; cpuset=&apos;4&apos;/&gt;</span><br><span class="line">  &lt;vcpupin vcpu=&apos;3&apos; cpuset=&apos;5&apos;/&gt;</span><br><span class="line">  &lt;vcpupin vcpu=&apos;4&apos; cpuset=&apos;6&apos;/&gt;</span><br><span class="line">  &lt;vcpupin vcpu=&apos;5&apos; cpuset=&apos;7&apos;/&gt;</span><br><span class="line">  &lt;vcpupin vcpu=&apos;6&apos; cpuset=&apos;8&apos;/&gt;</span><br><span class="line">  &lt;vcpupin vcpu=&apos;7&apos; cpuset=&apos;9&apos;/&gt;</span><br><span class="line">  &lt;emulatorpin cpuset=&apos;0-1&apos;/&gt;</span><br><span class="line">  &lt;iothreadpin iothread=&apos;1&apos; cpuset=&apos;0-1&apos;/&gt;</span><br><span class="line">&lt;/cputune&gt;</span><br><span class="line">    ...</span><br><span class="line">    &lt;topology sockets=&apos;1&apos; cores=&apos;4&apos; threads=&apos;2&apos;/&gt;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></p><h3 id="samba文件传输"><a href="#samba文件传输" class="headerlink" title="samba文件传输"></a>samba文件传输</h3><p>使用samba在manjaro和虚拟机间共享文件，安装完成后，新建文件夹在属性的share里设置共享权限。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 安装设置</span><br><span class="line">sudo pacman -S manjaro-settings-samba</span><br><span class="line"></span><br><span class="line"># 添加当前用户到sambashare组</span><br><span class="line">sudo usermod -a -G sambashare yourusername</span><br><span class="line">sudo systemctl enable smb nmb</span><br><span class="line">sudo systemctl start smb nmb</span><br><span class="line"></span><br><span class="line"># 设置samba密码</span><br><span class="line">sudo smbpasswd -a yourusername</span><br><span class="line"></span><br><span class="line"># 在win10虚拟机网络磁盘中填入host的ip，输入用户名和密码即可共享使用</span><br></pre></td></tr></table></figure></p><h3 id="onedrive"><a href="#onedrive" class="headerlink" title="onedrive"></a>onedrive</h3><p>manjaro也能用onedrive。<br><a href="https://github.com/abraunegg/onedrive/" target="_blank" rel="noopener">https://github.com/abraunegg/onedrive/</a><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yay -S onedrive-abrauneeg-git</span><br><span class="line"></span><br><span class="line"># 按说明设置</span><br><span class="line">onedrive</span><br><span class="line"></span><br><span class="line"># 开始同步（同步效果不太好，可能得多运行几次才能全部同步完成）</span><br><span class="line">onedrive --synchronize</span><br></pre></td></tr></table></figure></p><h3 id="下种子下种子"><a href="#下种子下种子" class="headerlink" title="下种子下种子"></a>下种子下种子</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo pacman -S qbittorrent</span><br></pre></td></tr></table></figure><h3 id="开机自动挂载ntfs硬盘"><a href="#开机自动挂载ntfs硬盘" class="headerlink" title="开机自动挂载ntfs硬盘"></a>开机自动挂载ntfs硬盘</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 编辑 /etc/fstab,文件末尾添加</span><br><span class="line">UUID=分区的UUID /你的特定目录 ntfs-3g defaults 0 0</span><br></pre></td></tr></table></figure><h3 id="ssh-keygen和git配置"><a href="#ssh-keygen和git配置" class="headerlink" title="ssh-keygen和git配置"></a>ssh-keygen和git配置</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen</span><br><span class="line"></span><br><span class="line">git config --global user.name &quot;your name&quot;</span><br><span class="line">git config --global user.email your@email</span><br></pre></td></tr></table></figure><h3 id="远程桌面"><a href="#远程桌面" class="headerlink" title="远程桌面"></a>远程桌面</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 安装Remmina和freerdp即可和windows远程桌面通信</span><br><span class="line">sudo pacman -Syu remmina freerdp</span><br></pre></td></tr></table></figure><h3 id="rslsync"><a href="#rslsync" class="headerlink" title="rslsync"></a>rslsync</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https://aur.archlinux.org/rslsync.git</span><br><span class="line">cd rslsync</span><br><span class="line">proxychains makepkg -Acs</span><br><span class="line">sudo pacman -U package.tar.xz</span><br></pre></td></tr></table></figure><h3 id="nordvpn"><a href="#nordvpn" class="headerlink" title="nordvpn"></a>nordvpn</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https://aur.archlinux.org/nordvpn-bin.git</span><br><span class="line">cd nordvpn-bin</span><br><span class="line">proxychains makepkg -Acs</span><br><span class="line">sudo pacman -U package.tar.xz</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
&lt;p&gt;最近换了linux系统，选择了manjaro发行版，在这里记录一下踩坑历程。
    
    </summary>
    
      <category term="linux" scheme="https://mrswolf.github.io/categories/linux/"/>
    
    
      <category term="manjaro" scheme="https://mrswolf.github.io/tags/manjaro/"/>
    
      <category term="linux" scheme="https://mrswolf.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>MATLAB分布式集群搭建记录</title>
    <link href="https://mrswolf.github.io/zh-cn/2019/05/20/MATLAB%E5%88%86%E5%B8%83%E5%BC%8F%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/"/>
    <id>https://mrswolf.github.io/zh-cn/2019/05/20/MATLAB分布式集群搭建记录/</id>
    <published>2019-05-20T06:05:02.000Z</published>
    <updated>2019-12-15T07:39:45.796Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><p>虽然我很久不用MATLAB处理日常工作，但是实验室主流依然是MATLAB（用Python的就那么几个T_T)。<a id="more"></a>以前小伙伴们跑程序都是拷贝程序和数据到实验室的计算服务器上，手工开N个MATLAB窗口做运算。现在实验室规模扩大，这种手工的方式越来越繁琐。我从前用MATLAB时就想试试集群计算，奈何当时实验室没啥硬件条件，正好现在有机会，我干脆搭了个MATLAB集群供小伙伴使用。</p><h2 id="软硬件"><a href="#软硬件" class="headerlink" title="软硬件"></a>软硬件</h2><p>硬件方面：</p><ul><li>4核心, 16GB内存， 百兆网卡普通台式机(manage节点)</li><li>40核心, 128GB内存, 千兆网卡计算服务器(compute1节点)</li><li>346TB存储， 千兆网卡存储服务器(storage节点)</li></ul><p>软件方面：</p><ul><li>Windows10专业版系统</li><li>centos7</li><li>matlab2017b</li></ul><p>网络环境：</p><ul><li>192.168.130.12(matlab-manage.xxx.org) — manage节点</li><li>192.168.130.11(matlab-compute1.xxx.org) — compute1节点</li><li>192.168.130.10 — storage节点</li></ul><p>MATLAB的帮助文档中提出，想要使用集群计算服务应该满足以下条件：</p><ul><li>推荐一个CPU核心最多创建一个worker</li><li>推荐每个worker最少可以使用2GB内存</li><li>最少5GB的硬盘空间容纳暂时性的数据文件</li><li>计算集群之间应当使用同构的计算架构(要求计算节点的硬件配置、系统和软件配置一致)</li></ul><h2 id="集群安装配置"><a href="#集群安装配置" class="headerlink" title="集群安装配置"></a>集群安装配置</h2><h3 id="ip域名设置"><a href="#ip域名设置" class="headerlink" title="ip域名设置"></a>ip域名设置</h3><p>修改compute节点和manage节点的计算机名、ip地址以及DNS域名解析，例如compute1节点的计算机名为matlab-compute1.xxx.org(xxx.org为后缀域名)，DNS域名也应该为matlab-compute1.xxx.org，ip地址为192.168.130.11。</p><blockquote><p>MATLAB分布式计算服务似乎要求计算机名要添加后缀域名(xxx.org)，否则在集群测试时会有解析不匹配的警告，Windows专业版可在<strong>这台电脑-属性-更改设置-更改-其他</strong>中添加主DNS后缀。</p></blockquote><h3 id="manage节点"><a href="#manage节点" class="headerlink" title="manage节点"></a>manage节点</h3><p>在manage节点安装matlab2017b，manage节点在安装过程中应该勾选MATLAB License Server和MATLAB Distributed Computing Server工具箱，前者为集群提供license认证服务，后者是分布式计算的核心服务组件。对于破解版的MATLAB，应该输入floating license的key而不是standalone的key，才能安装MATLAB License Server。安装完毕（并破解）后，在Windows服务选项卡中启动MATLAB License Server服务。<br><img src="/zh-cn/2019/05/20/MATLAB分布式集群搭建记录/license.png"><br>同时修改C:\Program Files\MATLAB\R2017b\licenses\network.lic为如下内容<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SERVER this_host ANY</span><br><span class="line">USE_SERVER</span><br></pre></td></tr></table></figure></p><p>修改C:\Program Files\MATLAB\R2017b\toolbox\distcomp\bin\mdce_def.bat其中的security level为2<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set SECURITY_LEVEL=2</span><br></pre></td></tr></table></figure></p><blockquote><p>设置security level为2的效果是要求用户在使用分布式计算服务时输入用户名，从而可以监控集群使用情况。</p></blockquote><p>启动MATLAB，切换到C:\Program Files\MATLAB\R2017b\toolbox\distcomp\bin目录下，在MATLAB命令行窗口输入如下命令安装并启动mdce服务<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">!mdce install </span><br><span class="line">!mdce start</span><br></pre></td></tr></table></figure></p><blockquote><p>最好在MATLAB命令行窗口内启动mdce服务，如果在Windows服务选项卡中启动服务，会出现权限问题导致集群worker无法连接。</p></blockquote><p>启动mdce服务后最好双击运行C:\Program Files\MATLAB\R2017b\toolbox\distcomp\bin\addMatlabToWindowsFirewall.bat文件（我的做法是直接关闭Windows防火墙避免多余的问题）</p><h3 id="compute节点"><a href="#compute节点" class="headerlink" title="compute节点"></a>compute节点</h3><p>compute节点的安装配置同manage节点，仅以下内容不同</p><ol><li>安装matlab时无需勾选MATLAB License Server工具箱</li><li>修改C:\Program Files\MATLAB\R2017b\licenses\network.lic为如下内容<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SERVER matlab-manage.xxx.org ANY</span><br><span class="line">USE_SERVER</span><br></pre></td></tr></table></figure></li></ol><p>此外为了跟storage节点连接，compute节点需要安装NFS服务，在<strong>程序和功能-启用或关闭Windows功能</strong>中勾选NFS服务<br><img src="/zh-cn/2019/05/20/MATLAB分布式集群搭建记录/nfs.png"></p><h2 id="storage节点"><a href="#storage节点" class="headerlink" title="storage节点"></a>storage节点</h2><p>storage节点设置NFS服务，NFS服务端安装和配置网上都有，我就不写了。</p><h3 id="添加集群节点"><a href="#添加集群节点" class="headerlink" title="添加集群节点"></a>添加集群节点</h3><p>在manage节点运行C:\Program Files\MATLAB\R2017b\toolbox\distcomp\bin\admincenter.bat，启动管理面板，点击<strong>Add or Find</strong>，添加manage节点和compute1节点，添加完毕后，点击<strong>Test Connectivity</strong>，测试通过如下图<br><img src="/zh-cn/2019/05/20/MATLAB分布式集群搭建记录/connectivity.png"></p><p>在MATLAB Job Scheduler面板点击start启动scheduler，输入名称，选择scheduler的节点为matlab-manage.xxx.org，因为security level为2，还需要设置管理员的密码。</p><p>设置好scheduler后，右键scheduler点击Start Workers，勾选compute1节点，设置启动的worker数量（我只有40个核心，所以启动40个worker）。<br><img src="/zh-cn/2019/05/20/MATLAB分布式集群搭建记录/center.png"></p><h3 id="客户端配置和使用"><a href="#客户端配置和使用" class="headerlink" title="客户端配置和使用"></a>客户端配置和使用</h3><p>MATLAB集群计算要求客户端的matlab版本和服务端一致，因为我服务端安装的是2017b，客户端也应该是matlab2017b。客户端可以选择standalone安装方式，也需要安装mdce服务添加防火墙配置并启动。<br>如果客户端想直接使用NFS服务，也需要在<strong>程序和功能-启用或关闭Windows功能</strong>中勾选NFS服务。<br>安装完毕后，在MATLAB主页中的<strong>Parallel</strong>选项选择<strong>Discover Cluster</strong>，勾选<strong>On your network</strong>，点击Next等待发现集群mjs40_2，选择集群，点击Next，Finish，就可以使用集群了，集群的使用情况可以在<strong>Parallel</strong>选项里<strong>Monitor Jobs</strong>查看。</p><p>这里提供两个matlab并行计算脚本检测集群配置是否正确<br><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%This demo shows how to use distributed computing server</span></span><br><span class="line"></span><br><span class="line">primeNumbers = <span class="built_in">primes</span>(uint64(<span class="number">2</span>^<span class="number">21</span>));</span><br><span class="line">compositeNumbers = primeNumbers.*primeNumbers(randperm(<span class="built_in">numel</span>(primeNumbers)));</span><br><span class="line">factors = <span class="built_in">zeros</span>(<span class="built_in">numel</span>(primeNumbers),<span class="number">2</span>);</span><br><span class="line">tic;</span><br><span class="line"><span class="keyword">parfor</span> idx = <span class="number">1</span>:<span class="built_in">numel</span>(compositeNumbers)</span><br><span class="line">    factors(idx,:) = <span class="built_in">factor</span>(compositeNumbers(idx));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">toc</span><br></pre></td></tr></table></figure></p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%This demo shows how to load data from nfs server, target_folder is nfs server ip address</span></span><br><span class="line"></span><br><span class="line">target_folder=<span class="string">'\\192.168.130.10\pub\data\';</span></span><br><span class="line"><span class="string">factors=zeros(400,2);</span></span><br><span class="line"><span class="string">tic;</span></span><br><span class="line"><span class="string">parfor i=0:399</span></span><br><span class="line"><span class="string">    tmp = load([target_folder,num2str(i),'</span>.mat']);</span><br><span class="line">    data = tmp.data;</span><br><span class="line">    factors(<span class="built_in">i</span>+<span class="number">1</span>, :)=<span class="built_in">factor</span>(data);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">toc</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
&lt;p&gt;虽然我很久不用MATLAB处理日常工作，但是实验室主流依然是MATLAB（用Python的就那么几个T_T)。
    
    </summary>
    
      <category term="偶尔用用的MATLAB" scheme="https://mrswolf.github.io/categories/%E5%81%B6%E5%B0%94%E7%94%A8%E7%94%A8%E7%9A%84MATLAB/"/>
    
    
      <category term="matlab" scheme="https://mrswolf.github.io/tags/matlab/"/>
    
  </entry>
  
  <entry>
    <title>（六）Psychopy事件响应</title>
    <link href="https://mrswolf.github.io/zh-cn/2019/01/08/%EF%BC%88%E5%85%AD%EF%BC%89Psychopy%E4%BA%8B%E4%BB%B6%E5%93%8D%E5%BA%94/"/>
    <id>https://mrswolf.github.io/zh-cn/2019/01/08/（六）Psychopy事件响应/</id>
    <published>2019-01-08T09:01:30.000Z</published>
    <updated>2019-12-15T07:41:58.309Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><a id="more"></a><h2 id="Psychopy事件响应"><a href="#Psychopy事件响应" class="headerlink" title="Psychopy事件响应"></a>Psychopy事件响应</h2><p>Psychopy提供了很多IO交互方式，当然，最根本的还是键盘和鼠标。本节介绍Psychopy鼠标和键盘的编程技巧。</p><h3 id="全局按键响应"><a href="#全局按键响应" class="headerlink" title="全局按键响应"></a>全局按键响应</h3><p>编写刺激界面免不了要反复调试，要看看字体颜色对不对、图形大小合不合适，一旦发现刺激界面需要改进就得退出程序修改源代码。</p><p>如果采用普通的按键检测方式，则需要在一个循环体内检查按键状态，这显然有可能造成不可知的错误（比如在检测按键前进入一个死循环函数，程序永远无法退出啦），这个时候全局按键响应就很有用了。</p><p>Psychopy用<a href="https://github.com/psychopy/psychopy/blob/master/psychopy/event.py" target="_blank" rel="noopener">psychopy.event.globalkeys</a>来设置全局按键，官方文档里没有如何使用全局按键的说明，但在coder的Demo里有演示global_event_keys.py。</p><p>global_event.keys.py程序注册了三个按键，按键“b”调用python的setattr函数，设置rect对象的填充颜色为蓝色,按键“ctrl”+“r”调用python的setattr函数，设置rect对象的填充颜色为红色。按键“q”调用core.quit方法终止程序退出。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> psychopy <span class="keyword">import</span> core, event, visual, monitors</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</span><br><span class="line">    mon = monitors.Monitor(</span><br><span class="line">        name=<span class="string">'my_monitor'</span>,</span><br><span class="line">        width=<span class="number">53.704</span>,  <span class="comment"># 显示器宽度，单位cm</span></span><br><span class="line">        distance=<span class="number">45</span>,   <span class="comment"># 被试距显示器距离，单位cm</span></span><br><span class="line">        gamma=<span class="keyword">None</span>,    <span class="comment"># gamma值</span></span><br><span class="line">        verbose=<span class="keyword">False</span>) <span class="comment"># 是否输出详细信息</span></span><br><span class="line">    mon.setSizePix((<span class="number">1920</span>, <span class="number">1080</span>)) <span class="comment"># 设置显示器分辨率</span></span><br><span class="line">    mon.save() <span class="comment"># 保存显示器信息</span></span><br><span class="line"></span><br><span class="line">    win = visual.Window(monitor=mon, size=(<span class="number">800</span>, <span class="number">600</span>), fullscr=<span class="keyword">False</span>,</span><br><span class="line">        screen=<span class="number">0</span>, winType=<span class="string">'pyglet'</span>, units=<span class="string">'norm'</span>, allowGUI=<span class="keyword">False</span>)</span><br><span class="line">    rect = visual.Rect(win, fillColor=<span class="string">'blue'</span>, pos=(<span class="number">0</span>, <span class="number">-0.2</span>))</span><br><span class="line">    text = visual.TextStim(</span><br><span class="line">        win,</span><br><span class="line">        pos=(<span class="number">0</span>, <span class="number">0.5</span>),</span><br><span class="line">        text=(<span class="string">'Press\n\n'</span></span><br><span class="line">              <span class="string">'B for blue rectangle,\n'</span></span><br><span class="line">              <span class="string">'CTRL + R for red rectangle,\n'</span></span><br><span class="line">              <span class="string">'Q or ESC to quit.'</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Add an event key.</span></span><br><span class="line">    event.globalKeys.add(key=<span class="string">'b'</span>, func=setattr,</span><br><span class="line">                         func_args=(rect, <span class="string">'fillColor'</span>, <span class="string">'blue'</span>),</span><br><span class="line">                         name=<span class="string">'blue rect'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Add an event key with a "modifier" (CTRL).</span></span><br><span class="line">    event.globalKeys.add(key=<span class="string">'r'</span>, modifiers=[<span class="string">'ctrl'</span>], func=setattr,</span><br><span class="line">                         func_args=(rect, <span class="string">'fillColor'</span>, <span class="string">'red'</span>),</span><br><span class="line">                         name=<span class="string">'red rect'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Add multiple shutdown keys "at once".</span></span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> [<span class="string">'q'</span>, <span class="string">'escape'</span>]:</span><br><span class="line">        event.globalKeys.add(key, func=core.quit)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Print all currently defined global event keys.</span></span><br><span class="line">    print(event.globalKeys)</span><br><span class="line">    print(repr(event.globalKeys))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        text.draw()</span><br><span class="line">        rect.draw()</span><br><span class="line">        win.flip()</span><br></pre></td></tr></table></figure></p><p>以下是event.globalkeys.add()方法的参数介绍<br>event.globalkeys.add(key, func, func_args=(), func_kwargs=None, modifiers=(), name=None)</p><div class="table-container"><table><thead><tr><th style="text-align:left">parameters</th><th style="text-align:left">type</th><th style="text-align:left">description</th></tr></thead><tbody><tr><td style="text-align:left">key</td><td style="text-align:left">string</td><td style="text-align:left">按键字符串</td></tr><tr><td style="text-align:left">func</td><td style="text-align:left">function</td><td style="text-align:left">按键时执行的函数</td></tr><tr><td style="text-align:left">func_args</td><td style="text-align:left">iterable</td><td style="text-align:left">函数的args参数</td></tr><tr><td style="text-align:left">func_kwargs</td><td style="text-align:left">dict</td><td style="text-align:left">函数的kwargs参数</td></tr><tr><td style="text-align:left">modifiers</td><td style="text-align:left">iterable</td><td style="text-align:left">组合按键字符串列表，例如’shift’,’ctrl’,’alt’,’capslock’,’scrollock’等</td></tr><tr><td style="text-align:left">name</td><td style="text-align:left">string</td><td style="text-align:left">按键事件的名称</td></tr></tbody></table></div><p>此外还有event.globalkeys.remove()方法以移除全局按键<br>event.globalkeys.remove(key, modifiers=())</p><div class="table-container"><table><thead><tr><th style="text-align:left">parameters</th><th style="text-align:left">type</th><th style="text-align:left">description</th></tr></thead><tbody><tr><td style="text-align:left">key</td><td style="text-align:left">string</td><td style="text-align:left">按键字符串</td></tr><tr><td style="text-align:left">modifiers</td><td style="text-align:left">iterable</td><td style="text-align:left">组合按键字符串列表，例如’shift’,’ctrl’,’alt’,’capslock’,’scrollock’等</td></tr></tbody></table></div><h3 id="等待按键和检测按键"><a href="#等待按键和检测按键" class="headerlink" title="等待按键和检测按键"></a>等待按键和检测按键</h3><p>除了全局按键响应，Psychopy还提供了等待按键响应和检测按键响应两种方式。</p><p>以下为等待按键函数event.waitKeys()的演示程序，按’esc’或五次其他按键退出程序。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> psychopy <span class="keyword">import</span> core, event, visual, monitors</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</span><br><span class="line">    mon = monitors.Monitor(</span><br><span class="line">        name=<span class="string">'my_monitor'</span>,</span><br><span class="line">        width=<span class="number">53.704</span>,  <span class="comment"># 显示器宽度，单位cm</span></span><br><span class="line">        distance=<span class="number">45</span>,   <span class="comment"># 被试距显示器距离，单位cm</span></span><br><span class="line">        gamma=<span class="keyword">None</span>,    <span class="comment"># gamma值</span></span><br><span class="line">        verbose=<span class="keyword">False</span>) <span class="comment"># 是否输出详细信息</span></span><br><span class="line">    mon.setSizePix((<span class="number">1920</span>, <span class="number">1080</span>)) <span class="comment"># 设置显示器分辨率</span></span><br><span class="line">    mon.save() <span class="comment"># 保存显示器信息</span></span><br><span class="line"></span><br><span class="line">    win = visual.Window(monitor=mon, size=(<span class="number">800</span>, <span class="number">600</span>), fullscr=<span class="keyword">False</span>,</span><br><span class="line">        screen=<span class="number">0</span>, winType=<span class="string">'pyglet'</span>, units=<span class="string">'norm'</span>, allowGUI=<span class="keyword">False</span>)</span><br><span class="line">    msg = visual.TextStim(win, text=<span class="string">'press a key\n &lt; esc &gt; to quit'</span>)</span><br><span class="line">    msg.draw()</span><br><span class="line">    win.flip()</span><br><span class="line"></span><br><span class="line">    k = [<span class="string">''</span>]</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> k[<span class="number">0</span>] <span class="keyword">not</span> <span class="keyword">in</span> [<span class="string">'escape'</span>, <span class="string">'esc'</span>] <span class="keyword">and</span> count &lt; <span class="number">5</span>:</span><br><span class="line">        k = event.waitKeys()</span><br><span class="line">        print(k)</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    win.close()</span><br><span class="line">    core.quit()</span><br></pre></td></tr></table></figure></p><p>event.waitKeys()阻塞函数进程直到被试按键，以下是<a href="http://www.psychopy.org/api/event.html" target="_blank" rel="noopener">event.waitKeys()</a>方法的参数介绍<br>event.waitKeys(maxWait=inf, keyList=None, modifiers=False, timeStamped=False, clearEvents=True)</p><div class="table-container"><table><thead><tr><th style="text-align:left">parameters</th><th style="text-align:left">type</th><th style="text-align:left">description</th></tr></thead><tbody><tr><td style="text-align:left">maxWait</td><td style="text-align:left">numeric value</td><td style="text-align:left">最大等待时间，默认为inf</td></tr><tr><td style="text-align:left">keyList</td><td style="text-align:left">iterable</td><td style="text-align:left">指定函数检测的按键名称，函数仅在按指定键时返回</td></tr><tr><td style="text-align:left">modifiers</td><td style="text-align:left">bool</td><td style="text-align:left">如果True，返回(keyname, modifiers)的tuple</td></tr><tr><td style="text-align:left">timeStamped</td><td style="text-align:left">bool</td><td style="text-align:left">如果True，返回(keyname, time)</td></tr><tr><td style="text-align:left">clearEvents</td><td style="text-align:left">bool</td><td style="text-align:left">如果True，在检测新的按键前清理event buffer</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th style="text-align:left">return</th><th style="text-align:left">type</th><th style="text-align:left">description</th></tr></thead><tbody><tr><td style="text-align:left">keys</td><td style="text-align:left">iterable</td><td style="text-align:left">按键列表；超时返回None</td></tr></tbody></table></div><p>等待按键会阻塞进程，Psychopy还提供了另一种非阻塞检测方式<a href="http://www.psychopy.org/api/event.html" target="_blank" rel="noopener">event.getKeys()</a>。</p><p>以下代码如下不断检测按键并输出，直到按’escape’键退出程序。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> psychopy <span class="keyword">import</span> core, event, visual, monitors</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</span><br><span class="line">    mon = monitors.Monitor(</span><br><span class="line">        name=<span class="string">'my_monitor'</span>,</span><br><span class="line">        width=<span class="number">53.704</span>,  <span class="comment"># 显示器宽度，单位cm</span></span><br><span class="line">        distance=<span class="number">45</span>,   <span class="comment"># 被试距显示器距离，单位cm</span></span><br><span class="line">        gamma=<span class="keyword">None</span>,    <span class="comment"># gamma值</span></span><br><span class="line">        verbose=<span class="keyword">False</span>) <span class="comment"># 是否输出详细信息</span></span><br><span class="line">    mon.setSizePix((<span class="number">1920</span>, <span class="number">1080</span>)) <span class="comment"># 设置显示器分辨率</span></span><br><span class="line">    mon.save() <span class="comment"># 保存显示器信息</span></span><br><span class="line"></span><br><span class="line">    win = visual.Window(monitor=mon, size=(<span class="number">800</span>, <span class="number">600</span>), fullscr=<span class="keyword">False</span>,</span><br><span class="line">        screen=<span class="number">0</span>, winType=<span class="string">'pyglet'</span>, units=<span class="string">'norm'</span>, allowGUI=<span class="keyword">False</span>)</span><br><span class="line">    msg = visual.TextStim(win, text=<span class="string">'press a key\n &lt; esc &gt; to quit'</span>)</span><br><span class="line">    msg.draw()</span><br><span class="line">    win.flip()</span><br><span class="line"></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        k = event.getKeys()</span><br><span class="line">        <span class="keyword">if</span> k:</span><br><span class="line">            <span class="keyword">if</span> <span class="string">'escape'</span> <span class="keyword">in</span> k:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            print(k)</span><br><span class="line"></span><br><span class="line">    win.close()</span><br><span class="line">    core.quit()</span><br></pre></td></tr></table></figure></p><p>以下是<a href="http://www.psychopy.org/api/event.html" target="_blank" rel="noopener">event.getKeys()</a>方法的参数介绍<br>event.getKeys(keyList=None, modifiers=False, timeStamped=False)</p><div class="table-container"><table><thead><tr><th style="text-align:left">parameters</th><th style="text-align:left">type</th><th style="text-align:left">description</th></tr></thead><tbody><tr><td style="text-align:left">keyList</td><td style="text-align:left">iterable</td><td style="text-align:left">指定函数检测的按键名称，函数仅在按指定键时返回</td></tr><tr><td style="text-align:left">modifiers</td><td style="text-align:left">bool</td><td style="text-align:left">如果True，返回(keyname, modifiers)的tuple</td></tr><tr><td style="text-align:left">timeStamped</td><td style="text-align:left">bool</td><td style="text-align:left">如果True，返回(keyname, time)</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th style="text-align:left">return</th><th style="text-align:left">type</th><th style="text-align:left">description</th></tr></thead><tbody><tr><td style="text-align:left">keys</td><td style="text-align:left">iterable</td><td style="text-align:left">按键列表；超时返回None</td></tr></tbody></table></div><h3 id="鼠标事件"><a href="#鼠标事件" class="headerlink" title="鼠标事件"></a>鼠标事件</h3><p>Psychopy提供<a href="http://www.psychopy.org/api/event.html" target="_blank" rel="noopener">event.Mouse</a>类来处理鼠标相关的事件，官方文档对此有详细的介绍。以下的代码显示了一个含有矩形的窗，在矩形内部单击左右键可以改变颜色，而按中央滚轮键则退出程序。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> psychopy <span class="keyword">import</span> core, event, visual, monitors</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</span><br><span class="line">    mon = monitors.Monitor(</span><br><span class="line">        name=<span class="string">'my_monitor'</span>,</span><br><span class="line">        width=<span class="number">53.704</span>,  <span class="comment"># 显示器宽度，单位cm</span></span><br><span class="line">        distance=<span class="number">45</span>,   <span class="comment"># 被试距显示器距离，单位cm</span></span><br><span class="line">        gamma=<span class="keyword">None</span>,    <span class="comment"># gamma值</span></span><br><span class="line">        verbose=<span class="keyword">False</span>) <span class="comment"># 是否输出详细信息</span></span><br><span class="line">    mon.setSizePix((<span class="number">1920</span>, <span class="number">1080</span>)) <span class="comment"># 设置显示器分辨率</span></span><br><span class="line">    mon.save() <span class="comment"># 保存显示器信息</span></span><br><span class="line"></span><br><span class="line">    win = visual.Window(monitor=mon, size=(<span class="number">800</span>, <span class="number">600</span>), fullscr=<span class="keyword">False</span>,</span><br><span class="line">        screen=<span class="number">0</span>, winType=<span class="string">'pyglet'</span>, units=<span class="string">'norm'</span>, allowGUI=<span class="keyword">True</span>)</span><br><span class="line">    rect = visual.Rect(win, fillColor=<span class="string">'blue'</span>, pos=(<span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 创建Mouse类</span></span><br><span class="line">    mouse = event.Mouse(visible=<span class="keyword">True</span>, newPos=(<span class="number">0</span>, <span class="number">0</span>), win=win)</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        <span class="comment"># 重置单击事件状态</span></span><br><span class="line">        mouse.clickReset()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 检测左键是否在矩形内单击</span></span><br><span class="line">        <span class="keyword">if</span> mouse.isPressedIn(rect, buttons=[<span class="number">0</span>]):</span><br><span class="line">            rect.fillColor = <span class="string">'red'</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 检测右键是否在矩形内单击</span></span><br><span class="line">        <span class="keyword">if</span> mouse.isPressedIn(rect, buttons=[<span class="number">2</span>]):</span><br><span class="line">            rect.fillColor = <span class="string">'blue'</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 检测是否单击滚轮键</span></span><br><span class="line">        <span class="comment"># button1: left click</span></span><br><span class="line">        <span class="comment"># button2: middle click</span></span><br><span class="line">        <span class="comment"># button3: right click</span></span><br><span class="line">        button1, button2, button3 = mouse.getPressed(getTime=<span class="keyword">False</span>)</span><br><span class="line">        <span class="keyword">if</span> button2:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        </span><br><span class="line">        rect.draw()</span><br><span class="line">        win.flip()</span><br><span class="line"></span><br><span class="line">    core.quit()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
    
    </summary>
    
      <category term="psychopy系列" scheme="https://mrswolf.github.io/categories/psychopy%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="psychopy" scheme="https://mrswolf.github.io/tags/psychopy/"/>
    
  </entry>
  
  <entry>
    <title>详解CSP</title>
    <link href="https://mrswolf.github.io/zh-cn/2019/01/06/%E8%AF%A6%E8%A7%A3CSP/"/>
    <id>https://mrswolf.github.io/zh-cn/2019/01/06/详解CSP/</id>
    <published>2019-01-06T07:41:21.000Z</published>
    <updated>2019-12-15T07:36:28.515Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="什么是CSP"><a href="#什么是CSP" class="headerlink" title="什么是CSP"></a>什么是CSP</h2><p>共空间模式(common spatial pattern,CSP)是脑-机接口领域常用的一类空间滤波算法，尤其在运动想象范式分类上具有较好的效果，是运动想象范式的基准算法之一。<a id="more"></a>目前，CSP及其改进算法的发展速度放缓，看似到达了算法的瓶颈期，近几年没有什么较大的突破。尽管如此，CSP中的一些数学思想对传统脑-机接口算法仍然具有较大的影响力，例如近年运用在SSVEP上的TRCA、DCPM等算法均和CSP有着异曲同工之妙。因此，本文从CSP原始算法出发，讨论其变形和一系列改进算法，试图为读者阐明其中的数学思想。</p><h3 id="CSP的历史"><a href="#CSP的历史" class="headerlink" title="CSP的历史"></a>CSP的历史</h3><p>1970年，<a href="https://www.computer.org/csdl/trans/tc/1970/04/01671511.pdf" target="_blank" rel="noopener">Fukunaga和Koontz</a>在IEEE Transactions on Computers上发表论文，介绍了一种特征选择的方法，史称“Fukunaga-Koontz变换”，这种特征选择的方法迅速在各个领域得到推广。</p><p>1990年，<a href="https://link.springer.com/article/10.1007/BF01129656" target="_blank" rel="noopener">Koles等人</a>将“Fukunaga-Koontz变换”引入背景脑电分析，发现可以通过脑电有效的区分健康人群和精神病人群。 </p><p>1999年，<a href="https://www.sciencedirect.com/science/article/pii/S1388245798000388" target="_blank" rel="noopener">MuÈller-Gerking和Pfurtscheller等人</a>（脑-机接口领域有名的Graz研究中心）把Koles的方法（他们对Koles的方法做了一些微小的改进）应用到运动分类上，并称这种方法为“common spatial pattern，CSP”。</p><p>次年，<a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.323.7160&amp;rep=rep1&amp;type=pdf" target="_blank" rel="noopener">Graz</a>小组的人又把CSP用在运动想象的分类上，取得比较好的分类效果，奠定了CSP在运动想象领域的地位。</p><h2 id="CSP（二分类）"><a href="#CSP（二分类）" class="headerlink" title="CSP（二分类）"></a>CSP（二分类）</h2><p>2000年<a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.323.7160&amp;rep=rep1&amp;type=pdf" target="_blank" rel="noopener">Graz</a>的论文中提出的CSP是为二分类问题设计的，形式较为简单，然而如果你读CSP相关论文，就会发现CSP存在至少三种表述形式。这三种方式相互联系，又有所区分，很容易让初学者陷入混乱，不知道哪一种是正确形式。</p><p>为了解决这一问题，使读者更好的理解其中的数学本质，我接下来从2000年<a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.323.7160&amp;rep=rep1&amp;type=pdf" target="_blank" rel="noopener">Graz</a>论文中的算法出发，讨论三种形式间的联系和不同。当然，我假设读者具有线性代数知识（了解特征值分解，了解一些矩阵的操作方法和符号）以及一些基础的numpy或MATLAB数据处理经验，并请读者牢记以下格言</p><blockquote><p>DON’T PANIC</p><footer><strong>The Hitchhiker's Guide to the Galaxy</strong><cite>Douglas Adams</cite></footer></blockquote><h3 id="CSP的原始形式"><a href="#CSP的原始形式" class="headerlink" title="CSP的原始形式"></a>CSP的原始形式</h3><p>假设我们做脑电实验，采集到两类不同的任务信号，用矩阵形式可以表示为$E^{(i)}_1 \in R^{N_c \times S}$和$E^{(i)}_2 \in R^{N_c \times S}$，其中$N_c$表示脑电导联数目，$S$表示采样点的个数，而上标$(i)$表示试次的序号（脑电实验通常会对一种任务进行多次实验，得到很多试次的数据），原始CSP算法采用以下步骤：</p><p><strong>第一步</strong>，对数据做decenter处理，即减去每一导联在样本点上的均值</p><script type="math/tex; mode=display">E^{(i)}_1 = E^{(i)}_1 - mean(E^{(i)}_1, axis=1) \\E^{(i)}_2 = E^{(i)}_2 - mean(E^{(i)}_2, axis=1)</script><p><strong>第二步</strong>，求每一试次的协方差矩阵并归一化，最后得到平均的协方差矩阵</p><script type="math/tex; mode=display">\bar{C}_1 = \sum_{i} \frac{E^{(i)}_1(E^{(i)}_1)^{T}}{trace(E^{(i)}_1(E^{(i)}_1)^{T})} \\\bar{C}_2 = \sum_{i} \frac{E^{(i)}_2(E^{(i)}_2)^{T}}{trace(E^{(i)}_2(E^{(i)}_2)^{T})}</script><p>这里的函数$trace()$是求矩阵的迹，即主对角线上的元素之和。注意到对于去均值的矩阵$E$，其协方差矩阵可以表示为$C = \frac{1}{S-1} EE^{T}$，上式中没有$S-1$出现是因为上下相除互相抵消。$\bar{C}_1$和$\bar{C}_2$则是两类任务信号的平均协方差矩阵。</p><blockquote><p>为什么要使用$trace()$来对协方差矩阵归一化？</p><p>1990年Koles的文章中指出，归一化的目的是为了消除”被试间脑电信号幅值的变化”，注意到Koles的原意是区分健康人群和精神疾病人群，而个体的脑电幅值是有绝对性的差异的。方差可以表征信号在时域上的能量高低，不同人群的协方差矩阵的绝对值不同。为了消除这种差异带来的影响，利用$trace()$函数求得所有导联的总体能量，并对协方差矩阵归一化，从而安排除不同个体带来的干扰。Graz小组对同一个体不同试次的数据沿用了这种归一化方式，试图消除试次间的差异，发现也有一定的作用，这种归一化方式就一直流传下来。</p><p>然而，有些分析显示这种归一化方式反而会削弱信号的可分性，建议不要使用归一化。关于这一点，我会在以后进行讨论。</p></blockquote><p><strong>第三步</strong>， 构建复合协方差矩阵，并特征值分解，构建白化（whitening）矩阵</p><script type="math/tex; mode=display">C_c = \bar{C}_1 + \bar{C}_2 \\C_c = V_cD_cV_c^{T}=\begin{bmatrix}v_1^{(c)} &v_2^{(c)} &\cdots &v_{N_c}^{(c)}\end{bmatrix}\begin{bmatrix}\lambda_1^{(c)} & & &\\& \lambda_2^{(c)} & &\\& & \ddots &\\& & & \lambda_{N_c}^{(c)}\end{bmatrix} \begin{bmatrix}v_1^{(c)} \\v_2^{(c)} \\\vdots \\v_{N_c}^{(c)}\end{bmatrix}\\P = D_c^{-1/2}V_c^{T}</script><p>其中$V_c$是特征向量矩阵（每一列是特征向量），$D_c$是由特征值组成的对角矩阵。$P$是白化矩阵，其目的是把对角矩阵$D_c$变化为单位矩阵$I$,即$PC_cP^{T} = I$成立。</p><p><strong>第四步</strong>，计算空间滤波器$W$</p><script type="math/tex; mode=display">\begin{align}I = PC_cP^{T} &= P\bar{C}_1P^{T} + P\bar{C}_2P^{T} \\&= S_1 + S_2 \\\end{align} \\S_1 = VD_1V^{T} = \begin{bmatrix}v_1 &v_2 &\cdots &v_{N_c}\end{bmatrix}\begin{bmatrix}\lambda_1^{(1)} & & &\\& \lambda_2^{(1)} & &\\& & \ddots &\\& & & \lambda_{N_c}^{(1)} \\\end{bmatrix} \begin{bmatrix}v_1 \\v_2 \\\vdots \\v_{N_c} \\\end{bmatrix}\\S_2 = VD_2V^{T} = \begin{bmatrix}v_1 &v_2 &\cdots &v_{N_c}\end{bmatrix}\begin{bmatrix}\lambda_1^{(2)} & & &\\& \lambda_2^{(2)} & &\\& & \ddots &\\& & & \lambda_{N_c}^{(2)} \\\end{bmatrix} \begin{bmatrix}v_1 \\v_2 \\\vdots \\v_{N_c} \\\end{bmatrix}\\W = P^TV</script><p>其中矩阵$S_1$和$S_2$具有同样的特征向量$V$（这也是共空间模式名称的由来），而相对应的特征值相加始终为1，即$D_1 + D_2 = I$。</p><blockquote><p>为什么$S_1$和$S_2$具有同样的特征向量和此消彼长的特征值关系？<br>这一点可以简单的证明如下<br>假设$v_j$和$\lambda_j^{(1)}$分别是$S_1$的特征向量和特征值，即</p><script type="math/tex; mode=display">S_1v_j=\lambda_j^{(1)}v_j</script><p>注意到$S_1+S_2=I$，把上式中的$S_1$置换掉可得</p><script type="math/tex; mode=display">(I-S_2)v_j=\lambda_j^{(1)}v_j</script><p>把上式变形一下可得</p><script type="math/tex; mode=display">S_2v_j=(1-\lambda_j^{(1)})v_j</script><p>显然$v_j$也是$S_2$的特征向量，只不过其特征值为$1-\lambda_j^{(1)}$</p></blockquote><p>这里还有一点需要注意，我们假设$S_1$特征值的顺序是按降序排列的（那么$S_2$的特征值就是按升序排列），即</p><script type="math/tex; mode=display">1 \ge \lambda_1^{(1)} \ge \lambda_2^{(1)} \ge \dots \ge \lambda_{N_c}^{(1)} \ge 0\\0 \le \lambda_1^{(2)} \le \lambda_2^{(2)} \le \dots \le \lambda_{N_c}^{(2)} \le 1\\</script><p>这种排序的主要目的是为了以后分析的便利性，例如在运动想象分类中提取最有效的空间滤波器。<br><blockquote><p>协方差矩阵是半正定矩阵（positive semidefinite），而半正定矩阵的特征值均为非负。故$S_1$和$S_2$的特征值在0~1之间</p></blockquote></p><p>以上就是原始CSP算法的基本内容，在得到空间滤波器矩阵$W$后（$W$的每一列都是一个空间滤波器），就可以对信号进行变换$Z=W^TE$，而$Z$的每一行则代表了滤波后的一个时序特征信号，接下来便可以对$Z$做进一步的分析。</p><p>简单回顾一下CSP算法，不难发现CSP实质求解的是这样一个问题，寻找正交矩阵$W$使得以下条件成立：</p><script type="math/tex; mode=display">W^T\bar{C}_1W= D_1 \\W^T\bar{C}_2W= D_2 \\D_1 + D_2 = I \\</script><p>让我们对以上的公式做一些变换，把第一个和第二个公式相加</p><script type="math/tex; mode=display">W^T(\bar{C}_1+\bar{C}_2)W=D_1+D_2=I</script><p>又因为$W$是正交矩阵，故$W^T=W^{-1}$，从而</p><script type="math/tex; mode=display">(\bar{C}_1+\bar{C}_2)W=W</script><p>把上式代入$\bar{C}_1W=WD_1$，可得</p><script type="math/tex; mode=display">\bar{C}_1W=(\bar{C}_1+\bar{C}_2)WD_1</script><p>这个式子是不是看起来很像特征向量定义的公式$\bar{C}_1W=WD_1$呢？只不过等式右边多了一个矩阵$\bar{C}_1+\bar{C}_2$。</p><p>这类形式的问题叫<a href="http://fourier.eng.hmc.edu/e161/lectures/algebra/node7.html" target="_blank" rel="noopener">广义特征值问题</a>，求解广义特征值问题是脑-机接口领域传统空间滤波方法的基础，大量的算法（CSP、TRCA等）都可以转化为这一形式。</p><p>下一小节中，我将从$\bar{C}_1W=(\bar{C}_1+\bar{C}_2)WD_1$这一公式出发来探讨CSP的第二种表述形式。</p><h3 id="CSP的第二种表述"><a href="#CSP的第二种表述" class="headerlink" title="CSP的第二种表述"></a>CSP的第二种表述</h3><p>在讨论CSP的第二种表述之前，我们需要了解一个数学概念<a href="https://en.wikipedia.org/wiki/Rayleigh_quotient" target="_blank" rel="noopener">广义雷利商（generalized Rayleigh quotient）</a>。</p><p>广义雷利商长这样</p><script type="math/tex; mode=display">R=\frac{w^TAw}{w^TBw} \\A, B \succeq 0 \\</script><p>其中$A$和$B$为半正定矩阵（读者可以简单理解为协方差矩阵），$w$是列向量，显然广义雷利商$R$是一个实数。</p><p>如果我们求如下广义雷利商的优化问题，就会有一些有趣的结果</p><script type="math/tex; mode=display">\underset{w}{\mathrm{max}} \frac{w^TAw}{w^TBw}</script><p>寻找$w$使得$R$最大，在数学上可以等价为求解下式（我就不证明了，感兴趣的读者可点击广义雷利商的链接查看证明过程）</p><script type="math/tex; mode=display">Aw=Bw\lambda_1</script><p>这个公式就是上一节提到的广义特征值问题，也就是说，寻找$w$使广义雷利商最大可以等价为求解$A$和$B$的广义特征值问题并找到使特征值$\lambda_1$最大所对应的特征向量$w$。</p><p>如果我们继续寻找能够使$R$第二大、第三大的$w$，就会发现只要解出广义特征值问题的矩阵形式即可</p><script type="math/tex; mode=display">AW= BWD= B \begin{bmatrix}w_1 &w_2 &\cdots &w_N\end{bmatrix}\begin{bmatrix}\lambda_1 & & &\\& \lambda_2 & &\\& & \ddots &\\& & & \lambda_N \\\end{bmatrix}</script><p>其中$\lambda_1 \ge \lambda_2 \ge \dots \ge \lambda_N$, 特征值的数值也就是广义雷利商的数值。</p><p>如果读者明白广义雷利商和广义特征值问题之间的关联，就不难发现，上一节中推导的CSP求解问题可以变形为求解广义雷利商问题</p><script type="math/tex; mode=display">\bar{C}_1W=(\bar{C}_1+\bar{C}_2)WD_1 \ \ \Longleftrightarrow \ \ \underset{w}{\mathrm{max}} \frac{w^T\bar{C}_1w}{w^T(\bar{C}_1+\bar{C}_2)w}</script><p>这里$A=\bar{C}_1$、$B=\bar{C}_1+\bar{C}_2$，$W$矩阵是广义雷利商第一大、第二大至第N大向量$w$组成的集合。</p><p>这里我们推出了CSP问题的第二种表述形式，即</p><script type="math/tex; mode=display">\underset{w}{\mathrm{max}} \frac{w^T\bar{C}_1w}{w^T(\bar{C}_1+\bar{C}_2)w}</script><h3 id="CSP的第三种表述"><a href="#CSP的第三种表述" class="headerlink" title="CSP的第三种表述"></a>CSP的第三种表述</h3><p>CSP的第三种表述形式需要绕点弯路。首先还是从CSP的原始形式出发，即寻找正交矩阵$W$使得以下条件成立：</p><script type="math/tex; mode=display">W^T\bar{C}_1W= D_1 \\W^T\bar{C}_2W= D_2 \\D_1 + D_2 = I \\</script><p>在第二个公式的左右两边同时右乘矩阵$W^{-1}\bar{C}_2^{-1}$，可以得到</p><script type="math/tex; mode=display">W^T=D_2W^{-1}\bar{C}_2^{-1}</script><p>把该式代入$W^T\bar{C}_1W= D_1$，替换掉$W^T$，可得</p><script type="math/tex; mode=display">D_2W^{-1}\bar{C}_2^{-1}\bar{C}_1W= D_1</script><p>上式左右两边左乘$\bar{C}_2WD_2^{-1}$，可得</p><script type="math/tex; mode=display">\begin{align}\bar{C}_1W &= \bar{C}_2WD_2^{-1}D_1 \\&=\bar{C}_2W\Lambda \\\end{align} \\\Lambda = D_2^{-1}D_1</script><p>没错，我们又推出了熟悉的广义特征值问题$\bar{C}_1W=\bar{C}_2W\Lambda$，再考虑广义雷利商与之的联系，可以得到CSP的第三种表述</p><script type="math/tex; mode=display">\underset{w}{\mathrm{max}} \frac{w^T\bar{C}_1w}{w^T\bar{C}_2w}</script><blockquote><p>相比CSP的原始形式和第二种表述形式，第三种表述形式更适合从直观上解释CSP在运动想象上有效的原因。<br>运动想象会产生事件相关同步（ERS）和事件相关去同步（ERD）的现象，简单来说就是从电信号上看，某些脑区能量升高，某些脑区能量降低，故能量变化才是运动想象分类的关键特征。</p><p>我们前面提高过，方差可以看作一导信号能量的高低（协方差矩阵则是多导信号的能量反应），因此CSP的第三种表述形式实质体现这样一个问题：<br>寻找一种变换方式$w$，使得变换后任务1的能量（$w^T\bar{C}_1w$）和任务2的能量（$w^T\bar{C}_2w$）差异最大化（其比值最大）。</p><p>CSP的这种特性恰好和运动想象的现象一致，CSP对能量特征做转换，强化了不同任务间能量差异。</p></blockquote><p>关于CSP的第三种表述，最后还需要注意的一点是其同CSP原始形式和第二种表述形式并不完全等价，我们在推导第三种表述形式过程种始终没有用到这样一个约束条件$D_1 + D_2 = I$。</p><p>这表明，第三种形式是CSP的一种泛化形式，其和CSP原始形式和第二种表述的差异仅在于特征值$\Lambda$不要求在0~1的范围内，具体来说，它们的特征值间存在这样一种关系</p><script type="math/tex; mode=display">\Lambda = D_2^{-1}D_1 \\D_1 = \Lambda(\Lambda + I)^{-1} \\D_2 = (\Lambda + I)^{-1} \\</script><h3 id="Talk-is-cheap-Show-me-the-code"><a href="#Talk-is-cheap-Show-me-the-code" class="headerlink" title="Talk is cheap. Show me the code."></a>Talk is cheap. Show me the code.</h3><p>TL;DR<br>我的实践经验表明，CSP第二种和第三种形式总要优于原始形式，主要是能够避免很多数值精度产生的问题。</p><p>如果你想试试原生的CSP，选第二种形式。</p><p>如果你能够理解其本质，第三种形式或许更合适(我喜欢第三种形式，因为从中可以引出CSP和Riemannian Geometry的关系，这一点以后再谈)</p><p>以下是三种CSP的代码<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> scipy.linalg <span class="keyword">as</span> linalg</span><br><span class="line"></span><br><span class="line"><span class="comment"># generate data</span></span><br><span class="line">X1 = np.random.rand(<span class="number">20</span>, <span class="number">60</span>, <span class="number">1000</span>)</span><br><span class="line">X2 = np.random.rand(<span class="number">20</span>, <span class="number">60</span>, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">csp1</span><span class="params">(X1, X2)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    The first form of CSP.</span></span><br><span class="line"><span class="string">    X1: # of trials, # of channels, # of samples</span></span><br><span class="line"><span class="string">    X2: # of trials, # of channels, # of samples</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Return</span></span><br><span class="line"><span class="string">    W: spatial fitlers</span></span><br><span class="line"><span class="string">    D1: eigenvalues of filters</span></span><br><span class="line"><span class="string">    '''</span> </span><br><span class="line">    X1 = X1 - X1.mean(axis=<span class="number">2</span>, keepdims=<span class="keyword">True</span>)</span><br><span class="line">    X2 = X2 - X2.mean(axis=<span class="number">2</span>, keepdims=<span class="keyword">True</span>)</span><br><span class="line">    <span class="comment"># normalization covariance</span></span><br><span class="line">    C1 = []</span><br><span class="line">    C2 = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(X1.shape[<span class="number">0</span>]):</span><br><span class="line">        tmp = X1[i,:,:].dot(X1[i,:,:].T)</span><br><span class="line">        tmp = tmp/np.trace(tmp)</span><br><span class="line">        C1.append(tmp)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(X2.shape[<span class="number">0</span>]):</span><br><span class="line">        tmp = X2[i,:,:].dot(X2[i,:,:].T)</span><br><span class="line">        tmp = tmp/np.trace(tmp)</span><br><span class="line">        C2.append(tmp)</span><br><span class="line">    C1 = np.array(C1)</span><br><span class="line">    C2 = np.array(C2)</span><br><span class="line">    <span class="comment"># average covariance</span></span><br><span class="line">    mean_C1 = C1.mean(axis=<span class="number">0</span>)</span><br><span class="line">    mean_C2 = C2.mean(axis=<span class="number">0</span>)</span><br><span class="line">    mean_C = mean_C1 + mean_C2</span><br><span class="line">    <span class="comment"># whitening matrix</span></span><br><span class="line">    D_c, V_c = linalg.eigh(mean_C)</span><br><span class="line">    isqrt_D_c = np.diag(np.sqrt(<span class="number">1</span>/D_c))</span><br><span class="line">    P = isqrt_D_c@V_c.T</span><br><span class="line">    <span class="comment"># S1 and S2</span></span><br><span class="line">    S1 = P@mean_C1@P.T</span><br><span class="line">    S2 = P@mean_C2@P.T</span><br><span class="line">    <span class="comment"># spatial filters</span></span><br><span class="line">    D1, V = linalg.eigh(S1)</span><br><span class="line">    W = P.T@V</span><br><span class="line">    <span class="keyword">return</span> W, D1</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">csp2</span><span class="params">(X1, X2)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    The second form of CSP.</span></span><br><span class="line"><span class="string">    X1: # of trials, # of channels, # of samples</span></span><br><span class="line"><span class="string">    X2: # of trials, # of channels, # of samples</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Return</span></span><br><span class="line"><span class="string">    W: spatial fitlers</span></span><br><span class="line"><span class="string">    D1: eigenvalues of filters</span></span><br><span class="line"><span class="string">    '''</span> </span><br><span class="line">    X1 = X1 - X1.mean(axis=<span class="number">2</span>, keepdims=<span class="keyword">True</span>)</span><br><span class="line">    X2 = X2 - X2.mean(axis=<span class="number">2</span>, keepdims=<span class="keyword">True</span>)</span><br><span class="line">    <span class="comment"># normalization covariance</span></span><br><span class="line">    C1 = []</span><br><span class="line">    C2 = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(X1.shape[<span class="number">0</span>]):</span><br><span class="line">        tmp = X1[i,:,:].dot(X1[i,:,:].T)</span><br><span class="line">        tmp = tmp/np.trace(tmp)</span><br><span class="line">        C1.append(tmp)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(X2.shape[<span class="number">0</span>]):</span><br><span class="line">        tmp = X2[i,:,:].dot(X2[i,:,:].T)</span><br><span class="line">        tmp = tmp/np.trace(tmp)</span><br><span class="line">        C2.append(tmp)</span><br><span class="line">    C1 = np.array(C1)</span><br><span class="line">    C2 = np.array(C2)</span><br><span class="line">    <span class="comment"># average covariance</span></span><br><span class="line">    mean_C1 = C1.mean(axis=<span class="number">0</span>)</span><br><span class="line">    mean_C2 = C2.mean(axis=<span class="number">0</span>)</span><br><span class="line">    mean_C = mean_C1 + mean_C2</span><br><span class="line">    <span class="comment"># generalized eigenvalue problem</span></span><br><span class="line">    D1, W = linalg.eigh(mean_C1,mean_C)</span><br><span class="line">    <span class="keyword">return</span> W, D1</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">csp3</span><span class="params">(X1, X2)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    The third form of CSP</span></span><br><span class="line"><span class="string">    X1: # of trials, # of channels, # of samples</span></span><br><span class="line"><span class="string">    X2: # of trials, # of channels, # of samples</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Return</span></span><br><span class="line"><span class="string">    W: spatial fitlers</span></span><br><span class="line"><span class="string">    D: eigenvalues of filters</span></span><br><span class="line"><span class="string">    '''</span> </span><br><span class="line">    X1 = X1 - X1.mean(axis=<span class="number">2</span>, keepdims=<span class="keyword">True</span>)</span><br><span class="line">    X2 = X2 - X2.mean(axis=<span class="number">2</span>, keepdims=<span class="keyword">True</span>)</span><br><span class="line">    <span class="comment"># normalization covariance</span></span><br><span class="line">    C1 = []</span><br><span class="line">    C2 = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(X1.shape[<span class="number">0</span>]):</span><br><span class="line">        tmp = X1[i,:,:].dot(X1[i,:,:].T)</span><br><span class="line">        tmp = tmp/np.trace(tmp)</span><br><span class="line">        C1.append(tmp)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(X2.shape[<span class="number">0</span>]):</span><br><span class="line">        tmp = X2[i,:,:].dot(X2[i,:,:].T)</span><br><span class="line">        tmp = tmp/np.trace(tmp)</span><br><span class="line">        C2.append(tmp)</span><br><span class="line">    C1 = np.array(C1)</span><br><span class="line">    C2 = np.array(C2)</span><br><span class="line">    <span class="comment"># average covariance</span></span><br><span class="line">    mean_C1 = C1.mean(axis=<span class="number">0</span>)</span><br><span class="line">    mean_C2 = C2.mean(axis=<span class="number">0</span>)</span><br><span class="line">    D, W = linalg.eigh(mean_C1, mean_C2)</span><br><span class="line">    <span class="keyword">return</span> W, D</span><br></pre></td></tr></table></figure></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">W1, D1 = csp1(X1, X2)</span><br><span class="line">W2, D2 = csp2(X1, X2)</span><br><span class="line">W3, D3 = csp3(X1, X2)</span><br></pre></td></tr></table></figure><p>让我们看一下CSP原始形式的第一个空间滤波器的特征值</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">D1[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><pre><code>0.4601822497625514</code></pre><p>再看一下CSP第二种表述形式的第一个空间滤波器的特征值，两者大致相同，但最后几位不太一样，这是由于数值舍入精度的问题（或许跟如何实施算法有关），关于这方面的问题我也在研究中，目前就忽略吧。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">D2[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><pre><code>0.46018224976254957</code></pre><p>再看一下CSP第三种表述形式的第一个空间滤波器的特征值，好像跟上面两者差别很大呢。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">D3[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><pre><code>0.8524770620457159</code></pre><p>回顾一下前文讨论的特征值间的联系，简单的做个变换，发现我们的算法是正确的。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># connection between form2 and form3</span></span><br><span class="line">new_D = D3/(D3+<span class="number">1</span>)</span><br><span class="line">new_D[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><pre><code>0.4601822497625497</code></pre><p>最后来看下空间滤波器（特征向量）是否正确，我们来检验第一特征向量的前5个数值。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">W1[:<span class="number">5</span>, <span class="number">0</span>]</span><br></pre></td></tr></table></figure><pre><code>array([ 1.56843115,  0.71217374, -0.50926103,  0.52207783, -0.29789071])</code></pre><p>第二种形式和CSP原始形式完全一致（有时会差一个正负号，但从算法上来说是完全正确的）</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># maybe negative, but that's ok</span></span><br><span class="line">W2[:<span class="number">5</span>, <span class="number">0</span>]</span><br></pre></td></tr></table></figure><pre><code>array([ 1.56843115,  0.71217374, -0.50926103,  0.52207783, -0.29789071])</code></pre><p>看一下第三种形式。咦，好像不太对哦。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># doesn't look like the result above. Is there something wrong?</span></span><br><span class="line">W3[:<span class="number">5</span>, <span class="number">0</span>]</span><br></pre></td></tr></table></figure><pre><code>array([ 2.13472472,  0.9693093 , -0.69313345,  0.71057786, -0.40544634])</code></pre><p>别慌，第三种形式只和第一种和第二种差了一个倍数（向量是一样的），做如下变换就能得到一样的结果。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Nothing is wrong here.</span></span><br><span class="line">np.sqrt(<span class="number">1</span>/(D3+<span class="number">1</span>))[<span class="number">0</span>]*W3[:<span class="number">5</span>, <span class="number">0</span>]</span><br></pre></td></tr></table></figure><pre><code>array([ 1.56843115,  0.71217374, -0.50926103,  0.52207783, -0.29789071])</code></pre><h2 id="CSP（多分类）"><a href="#CSP（多分类）" class="headerlink" title="CSP（多分类）"></a>CSP（多分类）</h2>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
&lt;h2 id=&quot;什么是CSP&quot;&gt;&lt;a href=&quot;#什么是CSP&quot; class=&quot;headerlink&quot; title=&quot;什么是CSP&quot;&gt;&lt;/a&gt;什么是CSP&lt;/h2&gt;&lt;p&gt;共空间模式(common spatial pattern,CSP)是脑-机接口领域常用的一类空间滤波算法，尤其在运动想象范式分类上具有较好的效果，是运动想象范式的基准算法之一。
    
    </summary>
    
      <category term="脑-机接口算法大全" scheme="https://mrswolf.github.io/categories/%E8%84%91-%E6%9C%BA%E6%8E%A5%E5%8F%A3%E7%AE%97%E6%B3%95%E5%A4%A7%E5%85%A8/"/>
    
    
      <category term="matrix decomposition" scheme="https://mrswolf.github.io/tags/matrix-decomposition/"/>
    
      <category term="brain-computer interface" scheme="https://mrswolf.github.io/tags/brain-computer-interface/"/>
    
  </entry>
  
  <entry>
    <title>（五）如何在Psychopy中新建窗口</title>
    <link href="https://mrswolf.github.io/zh-cn/2018/11/16/%EF%BC%88%E4%BA%94%EF%BC%89%E5%A6%82%E4%BD%95%E5%9C%A8Psychopy%E4%B8%AD%E6%96%B0%E5%BB%BA%E7%AA%97%E5%8F%A3/"/>
    <id>https://mrswolf.github.io/zh-cn/2018/11/16/（五）如何在Psychopy中新建窗口/</id>
    <published>2018-11-16T13:15:22.000Z</published>
    <updated>2019-12-15T07:29:26.300Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><a id="more"></a><h2 id="新建单窗口"><a href="#新建单窗口" class="headerlink" title="新建单窗口"></a>新建单窗口</h2><p>窗口(windows)是刺激呈现的舞台，任何刺激对象都需要指定其所属的窗口对象。Pyschopy的Window对象位于psychopy.visual模块中，一个最简单的窗口示例如下<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> psychopy <span class="keyword">import</span> visual, event, monitors, core</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据你自己的显示器调整显示器信息</span></span><br><span class="line">mon = monitors.Monitor(</span><br><span class="line">    name=<span class="string">'my_monitor'</span>,</span><br><span class="line">    width=<span class="number">53.704</span>,  <span class="comment"># 显示器宽度，单位cm</span></span><br><span class="line">    distance=<span class="number">45</span>,   <span class="comment"># 被试距显示器距离，单位cm</span></span><br><span class="line">    gamma=<span class="keyword">None</span>,    <span class="comment"># gamma值</span></span><br><span class="line">    verbose=<span class="keyword">False</span>) <span class="comment"># 是否输出详细信息</span></span><br><span class="line">mon.setSizePix((<span class="number">1920</span>, <span class="number">1080</span>)) <span class="comment"># 设置显示器分辨率</span></span><br><span class="line">mon.save() <span class="comment"># 保存显示器信息</span></span><br><span class="line"></span><br><span class="line">win = visual.Window(monitor=mon, size=(<span class="number">800</span>, <span class="number">600</span>), fullscr=<span class="keyword">False</span>,</span><br><span class="line">    screen=<span class="number">0</span>, winType=<span class="string">'pyglet'</span>, units=<span class="string">'norm'</span>, allowGUI=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line">event.waitKeys() <span class="comment"># 等待按键</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修复或预防原始gamma不能恢复bug(运行Psychopy程序显示器变暗加入以下代码)</span></span><br><span class="line"><span class="comment"># Pyschopy 3.0.0 版似乎修复了此bug，如果显示器没有变暗的现象可以不加入以下代码</span></span><br><span class="line">origLUT = np.round(win.backend._origGammaRamp * <span class="number">65535.0</span>).astype(<span class="string">"uint16"</span>)</span><br><span class="line">origLUT = origLUT.byteswap() / <span class="number">255.0</span></span><br><span class="line">win.backend._origGammaRamp = origLUT</span><br><span class="line">core.quit() <span class="comment"># 退出Psychopy程序</span></span><br></pre></td></tr></table></figure></p><p>Window对象用size参数申明窗口尺寸为800*600像素；fullscr参数决定是否全屏显示；screen参数决定了窗口在哪个显示器上显示，通常0是主显示器；winType参数决定了Psychopy使用的后端程序，有’pyglet’和’pygame’两种选择（Psychopy官方未来主要采用pyglet作为后端程序，我推荐采用pyglet）。</p><h2 id="新建多窗口"><a href="#新建多窗口" class="headerlink" title="新建多窗口"></a>新建多窗口</h2><p>Psychopy也可以同时建立多个窗口对象，注意仅pyglet后端支持多窗口行为。下面的代码展示了如何新建两个位于不同位置的窗口<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> psychopy <span class="keyword">import</span> visual, event, monitors, core</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据你自己的显示器调整显示器信息</span></span><br><span class="line">mon = monitors.Monitor(</span><br><span class="line">    name=<span class="string">'my_monitor'</span>,</span><br><span class="line">    width=<span class="number">53.704</span>,  <span class="comment"># 显示器宽度，单位cm</span></span><br><span class="line">    distance=<span class="number">45</span>,   <span class="comment"># 被试距显示器距离，单位cm</span></span><br><span class="line">    gamma=<span class="keyword">None</span>,    <span class="comment"># gamma值</span></span><br><span class="line">    verbose=<span class="keyword">False</span>) <span class="comment"># 是否输出详细信息</span></span><br><span class="line">mon.setSizePix((<span class="number">1920</span>, <span class="number">1080</span>)) <span class="comment"># 设置显示器分辨率</span></span><br><span class="line">mon.save() <span class="comment"># 保存显示器信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 窗口1在屏幕左上角</span></span><br><span class="line">win1 = visual.Window(monitor=mon, size=(<span class="number">800</span>, <span class="number">600</span>), pos=(<span class="number">0</span>, <span class="number">0</span>), fullscr=<span class="keyword">False</span>,</span><br><span class="line">    screen=<span class="number">0</span>, winType=<span class="string">'pyglet'</span>, units=<span class="string">'norm'</span>, allowGUI=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 窗口2在屏幕右下角</span></span><br><span class="line">win2 = visual.Window(monitor=mon, size=(<span class="number">800</span>, <span class="number">600</span>), pos=(<span class="number">1120</span>, <span class="number">480</span>), fullscr=<span class="keyword">False</span>,</span><br><span class="line">    screen=<span class="number">0</span>, winType=<span class="string">'pyglet'</span>, units=<span class="string">'norm'</span>, allowGUI=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line">event.waitKeys() <span class="comment"># 等待按键</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修复或预防原始gamma不能恢复bug(运行Psychopy程序显示器变暗加入以下代码)</span></span><br><span class="line"><span class="comment"># Pyschopy 3.0.0 版似乎修复了此bug，如果显示器没有变暗的现象可以不加入以下代码</span></span><br><span class="line"></span><br><span class="line">origLUT = np.round(win1.backend._origGammaRamp * <span class="number">65535.0</span>).astype(<span class="string">"uint16"</span>)</span><br><span class="line">origLUT = origLUT.byteswap() / <span class="number">255.0</span></span><br><span class="line">win1.backend._origGammaRamp = origLUT</span><br><span class="line">win2.backend._origGammaRamp = origLUT</span><br><span class="line">core.quit() <span class="comment"># 退出Psychopy程序</span></span><br></pre></td></tr></table></figure></p><p>pos参数调整窗口在屏幕上显示的位置，单位始终为像素，这里的坐标系不同于Psychopy的坐标系，以屏幕的左上角为原点，向下和向右分别为y轴和x轴的正方向。Window对象有很多可调整的参数和行为，具体细节可见<a href="http://www.psychopy.org/api/visual/window.html#psychopy.visual.Window" target="_blank" rel="noopener">官方文档Window API</a></p>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
    
    </summary>
    
      <category term="psychopy系列" scheme="https://mrswolf.github.io/categories/psychopy%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="psychopy" scheme="https://mrswolf.github.io/tags/psychopy/"/>
    
  </entry>
  
  <entry>
    <title>（二）Psychopy坐标系统与显示器设置</title>
    <link href="https://mrswolf.github.io/zh-cn/2018/11/11/%EF%BC%88%E4%BA%8C%EF%BC%89Psychopy%E5%9D%90%E6%A0%87%E7%B3%BB%E7%BB%9F%E4%B8%8E%E6%98%BE%E7%A4%BA%E5%99%A8%E8%AE%BE%E7%BD%AE/"/>
    <id>https://mrswolf.github.io/zh-cn/2018/11/11/（二）Psychopy坐标系统与显示器设置/</id>
    <published>2018-11-11T13:20:16.000Z</published>
    <updated>2019-12-15T07:40:32.947Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><a id="more"></a><h2 id="Psychopy的坐标系统"><a href="#Psychopy的坐标系统" class="headerlink" title="Psychopy的坐标系统"></a>Psychopy的坐标系统</h2><p>Psychopy提供了5种不同的坐标单位(unit)，使用者只需提供刺激对应的坐标单位，Psychopy会自动计算刺激所对应的像素点范围。这种多坐标单位的好处在于，能够开发和设备无关的刺激呈现，不需要每次实验都对刺激的大小和呈现位置进行调整。其劣势则是需要精心挑选刺激对应的坐标单位，有时还要在不同单位间进行转换，一不小心就容易出错。</p><p>无论何种单位，Psychopy的坐标系统始终以屏幕中心为原点(0, 0)，原点向上为正y轴，原点向右为正x轴。不同的Psychopy坐标单位的所需参考对象不同，例如norm、height的坐标单位是针对视窗对象(window)，而cm、deg、degFlat、degFlatPos、pix则是针对屏幕(screen)。<br><img src="/zh-cn/2018/11/11/（二）Psychopy坐标系统与显示器设置/coordinate.png" title="坐标系统"></p><h3 id="归一化单位-norm"><a href="#归一化单位-norm" class="headerlink" title="归一化单位(norm)"></a>归一化单位(norm)</h3><p>归一化单位可能是最常用的单位之一。在该单位下，window左下角坐标为(-1, -1)，window右上角坐标为(1, 1)。如图为长宽均为0.5的三个色块，其中心点分别位于(-0,5, 0)、(0, 0)和(0.5, 0)坐标下，注意window的分辨率为800*600，因此尽管色块的归一化长宽均为0.5，但其长实际为200像素点，宽实际为150像素点，表现为长方形。<br><img src="/zh-cn/2018/11/11/（二）Psychopy坐标系统与显示器设置/norm.png" title="norm单位"></p><h3 id="像素单位-pix"><a href="#像素单位-pix" class="headerlink" title="像素单位(pix)"></a>像素单位(pix)</h3><p>像素单位的坐标范围取决于screen的宽、高像素点数，假设screen宽度有w个像素点，高度有h个像素点，则screen左下角坐标为(-w/2, -h/2)，右上角坐标为(w/2, h/2)。</p><h3 id="厘米单位-cm"><a href="#厘米单位-cm" class="headerlink" title="厘米单位(cm)"></a>厘米单位(cm)</h3><p>厘米单位的坐标范围取决于screen的宽度和高度，假设screen宽度为w厘米，高度为h厘米，则screen左下角坐标为(-w/2, -h/2)，右上角坐标为(w/2, h/2)，每cm所代表的像素长度则由screen的像素点数确定。</p><h3 id="高度单位-height"><a href="#高度单位-height" class="headerlink" title="高度单位(height)"></a>高度单位(height)</h3><p>高度单位的坐标范围取决于window的宽高比。无论何种window，y轴的坐标范围始终是从-0.5到0.5。因此，如果window是4：3的尺寸，则window左下角坐标为(-0.6667, -0.5)，window右上角坐标为(0.6667, 0.5)；如果是16：9的尺寸，则window左下角坐标为(-0.8, -0.5)，window右上角坐标为(0.8, 0.5)。如图是800*600的window，色块的长宽均为1，则色块会占满y轴方向的所有空间。<br><img src="/zh-cn/2018/11/11/（二）Psychopy坐标系统与显示器设置/height.png" title="height单位"></p><h3 id="视角-deg-degFlatPos-degFlat"><a href="#视角-deg-degFlatPos-degFlat" class="headerlink" title="视角(deg, degFlatPos, degFlat)"></a>视角(deg, degFlatPos, degFlat)</h3><p>视角单位是五种单位种最复杂的坐标单位，使用该单位，不仅要知道屏幕的大小、像素点的多少，还要知道被试距离屏幕的距离，Psychopy提供三种不同的视角单位deg、degFlatPos和degFlat。<br><img src="/zh-cn/2018/11/11/（二）Psychopy坐标系统与显示器设置/deg.png" title="视角单位"></p><h4 id="deg"><a href="#deg" class="headerlink" title="deg"></a>deg</h4><p>deg单位默认视角在screen所有位置具有相同的像素长度，即在screen边缘位置和中心位置会产生相同大小的刺激图形。采用deg单位可以认为screen是球形曲面，而人眼则是球心，每度视角在screen所投射的像素长度完全相同。上图deg行红绿蓝三色块的长宽均为5度，位置分别为(-25, 10)、(0, 10)、(25, 10)。</p><h4 id="degFlatPos"><a href="#degFlatPos" class="headerlink" title="degFlatPos"></a>degFlatPos</h4><p>degFlatPos在deg的基础上考虑了位置在水平屏幕上的修正，远离屏幕中心的位置，刺激间的间隔越大，但是不改变刺激本身的大小。上图degFlatPos行三色块的参数同deg行完全相同，但因为采用了degFlatPos单位，红蓝色块距离绿色色块的距离要比deg行更大。</p><h4 id="degFlat"><a href="#degFlat" class="headerlink" title="degFlat"></a>degFlat</h4><p>degFlat不仅修正了位置信息，还修正了刺激的大小，因此，远离屏幕中心的位置，刺激尺寸越大，刺激间的间隔也越大。上图degFlat行三色块的参数同deg行完全相同，但因为采用了degFlat单位，不仅红蓝色块距离绿色色块的距离要比deg行更大，红蓝色块的形状也产生了畸变。</p><h3 id="Psychopy单位转换"><a href="#Psychopy单位转换" class="headerlink" title="Psychopy单位转换"></a>Psychopy单位转换</h3><p>Psychopy提供了不同单位间的转换方法，位于<a href="https://www.psychopy.org/api/tools/unittools.html" target="_blank" rel="noopener">psychopy.tools.unittools</a>模块中。</p><h2 id="Psychopy显示器信息设置"><a href="#Psychopy显示器信息设置" class="headerlink" title="Psychopy显示器信息设置"></a>Psychopy显示器信息设置</h2><p>以上提到的pix、cm、deg、degFlatPos和degFlag均需要提供显示器信息（尺寸、分辨率等），Psychopy提供两种方式设定显示设备信息。</p><h3 id="Moniter-Center界面"><a href="#Moniter-Center界面" class="headerlink" title="Moniter Center界面"></a>Moniter Center界面</h3><p>Anaconda Prompt下切换到<code>%Anaconda的安装目录%\Anaconda\Lib\site-packages\psychopy\monitors</code>目录，输入命令<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python MonitorCenter.py</span><br></pre></td></tr></table></figure><br><img src="/zh-cn/2018/11/11/（二）Psychopy坐标系统与显示器设置/monitor_center.png" title="Moniter Center界面"></p><h3 id="Moniter类"><a href="#Moniter类" class="headerlink" title="Moniter类"></a>Moniter类</h3><p>Moniter类位于<a href="http://www.psychopy.org/api/monitors.html" target="_blank" rel="noopener">psychopy.monitors</a>模块中，负责显示器参数和刺激环境设置。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Create my primary monitor</span></span><br><span class="line">mon = monitors.Monitor(</span><br><span class="line">    <span class="string">'monitor1'</span>,</span><br><span class="line">    width=<span class="number">53.704</span>,  <span class="comment"># width of the monitor in cm</span></span><br><span class="line">    distance=<span class="number">114</span>,  <span class="comment"># distance from viewer to the screen in cm</span></span><br><span class="line">    notes=<span class="string">"This is my primary monitor"</span>)</span><br><span class="line"></span><br><span class="line">mon.setSizePix((<span class="number">1920</span>, <span class="number">1080</span>))  <span class="comment"># set pixel size of the monitor</span></span><br><span class="line">mon.save()  <span class="comment"># save the monitor information to disk</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Reuse my primary monitor</span></span><br><span class="line">mon = monitors.Monitor(<span class="string">'monitor1'</span>)</span><br><span class="line"><span class="comment"># Change the distance from viewer to the screen</span></span><br><span class="line">mon.setDistance(<span class="number">200</span>)</span><br></pre></td></tr></table></figure><br>Monitor.save()函数保存的显示器信息位于<code>%APPDATA%psychopy3monitors</code>文件夹下，保存过一次后可以直接在Monitor类中以name调用。</p>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
    
    </summary>
    
      <category term="psychopy系列" scheme="https://mrswolf.github.io/categories/psychopy%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="psychopy" scheme="https://mrswolf.github.io/tags/psychopy/"/>
    
  </entry>
  
  <entry>
    <title>（一）Psychopy安装和使用</title>
    <link href="https://mrswolf.github.io/zh-cn/2018/11/10/%EF%BC%88%E4%B8%80%EF%BC%89Psychopy%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
    <id>https://mrswolf.github.io/zh-cn/2018/11/10/（一）Psychopy安装和使用/</id>
    <published>2018-11-10T12:59:35.000Z</published>
    <updated>2019-12-15T07:40:45.804Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><a id="more"></a><h2 id="什么是Psychopy"><a href="#什么是Psychopy" class="headerlink" title="什么是Psychopy"></a>什么是Psychopy</h2><p>Psychopy是基于Python的心理学实验设计软件，由英国诺丁汉大学的Jon Peirce主持开发。Psychopy结合了OpenGL的图形优势和Python的语法特性，给科学家们提供了快速构建高性能的图形刺激界面的工具。</p><h2 id="我为什么选择Psychopy"><a href="#我为什么选择Psychopy" class="headerlink" title="我为什么选择Psychopy"></a>我为什么选择Psychopy</h2><p>在我研究生阶段，我做脑机接口实验编写刺激界面的工具主要是Matlab平台的Psychtoolbox。很早之前，我也用过e-Prime，但很快就放弃了。e-Prime提供GUI界面，简单易学，但是无法设计复杂的刺激界面。相比之下，Psychtoolbox能够实现大多数脑-机接口刺激界面，同时基于Matlab平台，集成了大量简单方便的函数，对科研人员的编程要求不高，基本上是科研人员的第一选择。</p><p>然而对我而言，我一直不喜欢Matlab，理由有三：</p><ol><li><strong>Matlab不是一门真正的通用编程语言</strong>。Matlab本质是为不懂CS的科研人员设计的编程语言，很难进行普通程序的开发，例如GUI、网络编程等等。脑机接口一个很重要的方面是开发和机器交互的程序，这些程序有时很注重性能，Matlab开发这些功能不太方便。</li><li><strong>Matlab是收费的商业软件</strong>，其工具包的价格不是穷学生能承受的。尽管天朝存在“破解版”这种Matlab版本，MathWorks公司对科研人员使用破解版也视而不见，但谁知道以后会怎么样呢？为了不受制于人，我决定转向开源软件阵营。</li><li><strong>最重要的一点，学Matlab找不到工作</strong>。研究生转博士期间，我也跟着校招参加了不少面试。很遗憾，在脑机接口领域，对口的工作几乎没有；就算扩大了从生物医学工程专业来说，大部分工作机会还是集中在医疗图像领域。这些领域的招聘要求中可没有熟练使用Matlab这一项，大部分还是C/C++、Java等通用编程语言。</li></ol><p>综上所述，我在博士阶段毅然决然的放弃了Matlab，放弃了以前所有的代码，转向了Python。而在Python平台下，Psychopy几乎是唯一选择（个人认为）。Psychopy目前虽然仍处在开发阶段，还有不少bug，官方文档也不完善，但是官方社区和开发者相当活跃，使用人数也越来越多，借着Python语言的上升势头，我认为不久之后Psychopy很可能成为神经科学及脑机接口设计实验的首选框架。</p><p>当然由于Psychopy还很年轻，我在Psychopy实践过程中遇到许多问题。写Psychopy系列博文的目的是记录我的开发经验，给想使用Psyhcopy却遇到问题的朋友提供帮助。</p><h2 id="安装Anaconda和Psychopy"><a href="#安装Anaconda和Psychopy" class="headerlink" title="安装Anaconda和Psychopy"></a>安装Anaconda和Psychopy</h2><p>Anaconda是一个用于科学计算的Python发行版，集成了大量Python科学计算所需的环境库，提供包管理和环境管理的功能，免去了手动安装Python及其各种工具包的麻烦。Anaconda支持Linux、Mac和Windows系统，在Windows下几乎是科学计算的唯一选择。我推荐安装Anaconda或Miniconda的最新版本，Anaconda的下载地址可在其<a href="https://www.anaconda.com/download/" target="_blank" rel="noopener">官网</a>或<a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/" target="_blank" rel="noopener">清华TUNA镜像站</a>找到。</p><p>Psychopy在2019年10月8号release了3.2.4 (PyPi上为3.2.3)，相比3.0.0添加了很多特性，修复了大量bug。尽管官方提供了多种<a href="https://www.psychopy.org/download.html" target="_blank" rel="noopener">安装方式</a>，我仍建议使用Anaconda或Miniconda安装（pip会存在一些编译依赖缺失问题）。</p><p>Psychopy在Python3.6版本下较为稳定，在Anaconda Prompt中键入如下命令创建环境并安装:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conda create -n psypy3 python=3.6</span><br><span class="line">conda activate psypy3</span><br><span class="line">conda install numpy scipy matplotlib pandas pyopengl pillow lxml openpyxl xlrd configobj pyyaml gevent greenlet msgpack-python psutil pytables requests[security] cffi seaborn wxpython cython pyzmq pyserial</span><br><span class="line">conda install -c conda-forge pyglet pysoundfile python-bidi moviepy pyosf</span><br><span class="line">pip install zmq json-tricks pyparallel sounddevice pygame pysoundcard psychopy_ext psychopy</span><br></pre></td></tr></table></figure></p><p>在python控制台中运行如下命令检查Psychopy版本<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> psychopy</span><br><span class="line">print(psychopy.__version__)</span><br></pre></td></tr></table></figure></p><h2 id="使用Psychopy"><a href="#使用Psychopy" class="headerlink" title="使用Psychopy"></a>使用Psychopy</h2><p>Psychopy提供两种刺激界面设计方式，一种是类似e-Prime的GUI界面Builder，另一种是普通的脚本编写方式Coder。</p><h3 id="Builder"><a href="#Builder" class="headerlink" title="Builder"></a>Builder</h3><p>在Anaconda Prompt中切换到Psychopy的app安装目录，Windows下通常为<code>cd %Anaconda的安装目录%\Anaconda\Lib\site-packages\psychopy\app</code>，在该目录下运行命令<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python psychopyApp.py -b</span><br></pre></td></tr></table></figure><br><img src="/zh-cn/2018/11/10/（一）Psychopy安装和使用/builder.png" title="Builder界面"><br>Builder的使用在<a href="http://www.psychopy.org/builder/builder.html" target="_blank" rel="noopener">Builder - building experiments in a GUI</a>文档中有详细的介绍，builder很适合设计一些简单的刺激界面，设计完成的界面也可以转换为Coder中的脚本程序。</p><h3 id="Coder"><a href="#Coder" class="headerlink" title="Coder"></a>Coder</h3><p>在Anaconda Prompt中切换到Psychopy的app安装目录，Windows下通常为<code>%Anaconda的安装目录%\Anaconda\Lib\site-packages\psychopy\app</code>，在该目录下运行命令<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python psychopyApp.py -c</span><br></pre></td></tr></table></figure><br><img src="/zh-cn/2018/11/10/（一）Psychopy安装和使用/coder.png" title="Coder界面"><br>Coder的使用在<a href="http://www.psychopy.org/coder/coder.html" target="_blank" rel="noopener">Coder - writing experiments with scripts</a>文档中有详细的介绍，相比Builder，Coder提供的编程设计方式更加灵活，可以实现更为复杂的刺激界面。当然Coder本身只是提供了开发环境，脚本编写可以在任何编辑器下进行，我很少直接使用Coder，通常会使用<del>Pycharm和Sublime Text</del> vscode 来编写程序。</p><h2 id="Psychopy相关资源"><a href="#Psychopy相关资源" class="headerlink" title="Psychopy相关资源"></a>Psychopy相关资源</h2><p><del>Psychopy的官方文档更新不算及时，大部分文档还是基于Python2的版本</del>Psychopy官方文档已更新至Python3，并不再支持Python2。官方文档和demo仍然是学习Psychopy的不二之选。如果有问题在官方文档里没有说明，Google也没有相关信息的话，可以去Psychopy的论坛问问或Github提个issue。</p><p><a href="https://discourse.psychopy.org/" target="_blank" rel="noopener">Psychopy 官方文档</a><br><a href="http://www.psychopy.org/api/api.html" target="_blank" rel="noopener">Psychopy API手册</a><br><a href="https://discourse.psychopy.org/" target="_blank" rel="noopener">Psychopy 论坛</a><br><a href="https://github.com/psychopy/psychopy" target="_blank" rel="noopener">Psychopy Github仓库</a></p>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
    
    </summary>
    
      <category term="psychopy系列" scheme="https://mrswolf.github.io/categories/psychopy%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="psychopy" scheme="https://mrswolf.github.io/tags/psychopy/"/>
    
  </entry>
  
  <entry>
    <title>博客测试</title>
    <link href="https://mrswolf.github.io/zh-cn/2018/11/09/%E5%8D%9A%E5%AE%A2%E6%B5%8B%E8%AF%95/"/>
    <id>https://mrswolf.github.io/zh-cn/2018/11/09/博客测试/</id>
    <published>2018-11-09T13:03:15.000Z</published>
    <updated>2019-12-15T07:41:17.608Z</updated>
    
    <content type="html"><![CDATA[<p>swolf的博客开通啦！本博客记录我在学习过程中的心得体会。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;swolf的博客开通啦！本博客记录我在学习过程中的心得体会。&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
</feed>
